<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Impulse</name>
    </assembly>
    <members>
        <member name="T:Impulse.InvalidLiteralException">
            <summary>
            Exception raised when a literal is in the wrong format for parsing
            </summary>
        </member>
        <member name="M:Impulse.InvalidLiteralException.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new object representing an invalid literal exception
            </summary>
            <param name="message">The message for debugging purposes</param>
            <param name="text">The text of the literal being parsed</param>
            <param name="paramName">The name of the parameter the literal was stored in</param>
        </member>
        <member name="M:Impulse.InvalidLiteralException.#ctor(System.String,System.String,System.String,System.Exception)">
            <summary>
            Creates a new object representing an invalid literal exception
            </summary>
            <param name="message">The message for debugging purposes</param>
            <param name="text">The text of the literal being parsed</param>
            <param name="paramName">The name of the parameter the literal was stored in</param>
            <param name="innerException">The inner exception causing this one</param>
        </member>
        <member name="P:Impulse.InvalidLiteralException.Text">
            <summary>
            Gets the text of the literal
            </summary>
        </member>
        <member name="P:Impulse.InvalidLiteralException.ParameterName">
            <summary>
            Gets the parameter name
            </summary>
        </member>
        <member name="T:Impulse.InvalidParameterException">
            <summary>
            Exception raised when a parameter causes an exception
            </summary>
        </member>
        <member name="M:Impulse.InvalidParameterException.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Creates an object representing an invalid parameter exception
            </summary>
            <param name="message">The message for debugging purposes</param>
            <param name="stepID">The ID of the step containing the parameter</param>
            <param name="paramName">The name of the parameter</param>
        </member>
        <member name="M:Impulse.InvalidParameterException.#ctor(System.String,System.Int32,System.String,System.Exception)">
            <summary>
            Creates an object representing an invalid parameter exception
            </summary>
            <param name="message">The message for debugging purposes</param>
            <param name="stepID">The ID of the step containing the parameter</param>
            <param name="paramName">The name of the parameter</param>
            <param name="innerException">The inner excpetion causing this one</param>
        </member>
        <member name="P:Impulse.InvalidParameterException.StepID">
            <summary>
            Gets the ID of the step containing the parameter
            </summary>
        </member>
        <member name="P:Impulse.InvalidParameterException.ParameterName">
            <summary>
            Gets the name of the parameter causing the exception
            </summary>
        </member>
        <member name="T:Impulse.v_0_1.Binding">
            <summary>
            Class representing a binding
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Binding.#ctor">
            <summary>
            Creates a new binding
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Binding.#ctor(Impulse.v_0_1.Constant)">
            <summary>
            Creates a new binding bound to a particular constant
            </summary>
            <param name="binding">The constant to bind to</param>
        </member>
        <member name="M:Impulse.v_0_1.Binding.#ctor(Impulse.v_0_1.Constant,System.Collections.Generic.IEnumerable{Impulse.v_0_1.Variable})">
            <summary>
            Creates a new binding an enumeration of variables to a particular constant
            </summary>
            <param name="binding">The constant to bind to</param>
            <param name="coBindings">The variables to bind</param>
        </member>
        <member name="M:Impulse.v_0_1.Binding.IsCoBound(Impulse.v_0_1.Variable)">
            <summary>
            Determines if a particular variable is contained in the binding
            </summary>
            <param name="variable">The variable to check</param>
            <returns><see langword="true"/> if the variable is bound in this binding, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Binding.TryMerge(Impulse.v_0_1.Binding,Impulse.v_0_1.Binding,Impulse.v_0_1.Binding@)">
            <summary>
            Try to merge to sets of bindings together
            </summary>
            <param name="one">The first binding</param>
            <param name="two">The second binding</param>
            <param name="result">The resulting binding, if possible</param>
            <returns><see langword="true"/> if the two bindings can be unified, <see langword="false"/> otherwise</returns>
        </member>
        <member name="P:Impulse.v_0_1.Binding.BoundConstant">
            <summary>
            Gets or sets the bound constant
            </summary>
        </member>
        <member name="P:Impulse.v_0_1.Binding.Bound">
            <summary>
            Gets whether the binding is bound to a constant
            </summary>
        </member>
        <member name="P:Impulse.v_0_1.Binding.CoBindings">
            <summary>
            Gets a list of the variables that are bound together
            </summary>
        </member>
        <member name="T:Impulse.v_0_1.Bindings">
            <summary>
            Class represeting a dictionary of variables to bindings
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Bindings.#ctor">
            <summary>
            Create a new dictionary of bindings
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Bindings.GetBinding(Impulse.v_0_1.Variable,Impulse.v_0_1.Binding@)">
            <summary>
            Gets the binding for a given variable
            </summary>
            <param name="variable">The variable to look up</param>
            <param name="binding">The resulting binding, if found</param>
            <returns><see langword="true"/> if the varibale is found in this set of bindings, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Bindings.AddCoBinding(Impulse.v_0_1.Variable,Impulse.v_0_1.Variable)">
            <summary>
            Add a new binding between two variables if possible
            </summary>
            <param name="a">The first variable to bind</param>
            <param name="b">The second variable to bind</param>
            <returns><see langword="true"/> if the varibales can be bound together, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Bindings.AddBinding(Impulse.v_0_1.Variable,Impulse.v_0_1.Constant)">
            <summary>
            Add a new binding between a variable and a constant if possible
            </summary>
            <param name="a">The variable to bind</param>
            <param name="b">The constant to bind</param>
            <returns><see langword="true"/> if the terms can be bound together, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Bindings.TryMerge(Impulse.v_0_1.Bindings,Impulse.v_0_1.Bindings,Impulse.v_0_1.Bindings@)">
            <summary>
            Not implemented. Try to merge to sets of bindings together
            </summary>
            <param name="one">The first bindings</param>
            <param name="two">The second bindings</param>
            <param name="result">The resulting bindings, if possible</param>
            <returns><see langword="true"/> if the two bindings can be unified, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Bindings.GetEnumerator">
            <summary>
            Gets an enumerator for the bindings, will likely contain duplicates
            </summary>
            <returns>An enumerator for the bindings</returns>
        </member>
        <member name="T:Impulse.v_0_1.Term">
            <summary>
            Class representing an abstract term
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Term.#ctor(System.String)">
            <summary>
            Constructs a new term with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Impulse.v_0_1.Term.Equals(System.Object)">
            <summary>
            Abstract. Determines if this term is equal to a given object
            </summary>
            <param name="obj">The object to compare</param>
            <returns><see langword="true"/> if the objects are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Term.Equals(Impulse.v_0_1.Term)">
            <summary>
            Abstract. Determines if this term is equal to another term
            </summary>
            <param name="term">The term to compare</param>
            <returns><see langword="true"/> if the terms are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Term.GetHashCode">
            <summary>
            Abstract. Gets the hash code of the current term
            </summary>
            <returns></returns>
        </member>
        <member name="M:Impulse.v_0_1.Term.ToString">
            <summary>
            Abstract. Converts the term to a string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Impulse.v_0_1.Term.Unify(Impulse.v_0_1.Term,Impulse.v_0_1.Term@)">
            <summary>
            Abstract. Unifies this term with another term
            </summary>
            <param name="term">The term to unify</param>
            <param name="result">The resulting unified term</param>
            <returns><see langword="true"/> if the terms unify, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Term.op_Equality(Impulse.v_0_1.Term,Impulse.v_0_1.Term)">
            <summary>
            Determines if two terms are equal
            </summary>
            <param name="left">The left hand side term to compare</param>
            <param name="right">The right hand side term to compare</param>
            <returns><see langword="true"/> if the objects are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Term.op_Inequality(Impulse.v_0_1.Term,Impulse.v_0_1.Term)">
            <summary>
            Determines if two terms are equal
            </summary>
            <param name="left">The left hand side term to compare</param>
            <param name="right">The right hand side term to compare</param>
            <returns><see langword="false"/> if the objects are equal, <see langword="true"/> otherwise</returns>
        </member>
        <member name="P:Impulse.v_0_1.Term.Name">
            <summary>
            Gets or sets the name of this term
            </summary>
        </member>
        <member name="T:Impulse.v_0_1.AtomicTerm">
            <summary>
            Class represting the base type of constants and variables
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.AtomicTerm.#ctor(System.String,System.String)">
            <summary>
            Creates a new atomic term with specified name and type
            </summary>
            <param name="name">The name of the term</param>
            <param name="type">The type of the term, may be <see langword="null"/></param>
        </member>
        <member name="M:Impulse.v_0_1.AtomicTerm.ToString">
            <summary>
            Converts this term to is string representation
            </summary>
            <returns>The term's name</returns>
        </member>
        <member name="M:Impulse.v_0_1.AtomicTerm.FromString(System.String)">
            <summary>
            Constructs an atomic term from a string
            </summary>
            <param name="term">The text of the term</param>
            <returns>Either a <see cref="T:Impulse.v_0_1.Constant"/> or a <see cref="T:Impulse.v_0_1.Variable"/> if the name starts with '?'</returns>
        </member>
        <member name="P:Impulse.v_0_1.AtomicTerm.Type">
            <summary>
            Gets or sets the type of the term
            </summary>
        </member>
        <member name="T:Impulse.v_0_1.Constant">
            <summary>
            Class representing a constant term
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Constant.#ctor(System.String)">
            <summary>
            Constructs a new constant with the specified name
            </summary>
            <param name="name">The name of the new constant, must not start with '?'</param>
        </member>
        <member name="M:Impulse.v_0_1.Constant.#ctor(System.String,System.String)">
            <summary>
            Constructs a new constant with the specified name and type
            </summary>
            <param name="name">The name of the new constant, must not start with '?'</param>
            <param name="type">The type of the new constant</param>
        </member>
        <member name="M:Impulse.v_0_1.Constant.Equals(System.Object)">
            <summary>
            Determines if this constant is equal to a given object
            </summary>
            <param name="obj">The object to compare</param>
            <returns><see langword="true"/> if the objects are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Constant.Equals(Impulse.v_0_1.Term)">
            <summary>
            Determines if this constant is equal to a given term
            </summary>
            <param name="term">The term to compare</param>
            <returns><see langword="true"/> if the terms are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Constant.Equals(Impulse.v_0_1.Constant)">
            <summary>
            Determines if this constant is equal to another constant
            </summary>
            <param name="term">The constant to compare</param>
            <returns><see langword="true"/> if the constants are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Constant.GetHashCode">
            <summary>
            Gets the hash code of the constant, which is the hash of its name
            </summary>
            <returns>The hash code of the constant</returns>
        </member>
        <member name="M:Impulse.v_0_1.Constant.Unify(Impulse.v_0_1.Term,Impulse.v_0_1.Term@)">
            <summary>
            Unifies this constant with another term
            </summary>
            <param name="term">The term to unify</param>
            <param name="result">The resulting unified term</param>
            <returns><see langword="true"/> if the terms unify, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Variable.#ctor(System.String)">
            <summary>
            Constructs a new variable with the specified name
            </summary>
            <param name="name">The name of the new variable, must start with '?'</param>
        </member>
        <member name="M:Impulse.v_0_1.Variable.#ctor(System.String,System.String)">
            <summary>
            Constructs a new variable with the specified name and type
            </summary>
            <param name="name">The name of the new variable, must start with '?'</param>
            <param name="type">The type of the new variable</param>
        </member>
        <member name="M:Impulse.v_0_1.Variable.Equals(System.Object)">
            <summary>
            Determines if this variable is equal to a given object
            </summary>
            <param name="obj">The object to compare</param>
            <returns><see langword="true"/> if the objects are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Variable.Equals(Impulse.v_0_1.Term)">
            <summary>
            Determines if this variable is equal to a given term
            </summary>
            <param name="term">The term to compare</param>
            <returns><see langword="true"/> if the terms are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Variable.Equals(Impulse.v_0_1.Variable)">
            <summary>
            Determines if this variable is equal to another constant
            </summary>
            <param name="term">The variable to compare</param>
            <returns><see langword="true"/> if the variables are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Variable.GetHashCode">
            <summary>
            Gets the hash code of the variable, which is the hash of its name
            </summary>
            <returns>The hash code of the variable</returns>
        </member>
        <member name="M:Impulse.v_0_1.Variable.ToBoundString">
            <summary>
            Converts this variable to a string representation using its bindings
            </summary>
            <returns>Either the name of the variable or the constant it is bound to if it exists</returns>
        </member>
        <member name="M:Impulse.v_0_1.Variable.Unify(Impulse.v_0_1.Term,Impulse.v_0_1.Term@)">
            <summary>
            Unifies this variable with another term
            </summary>
            <param name="term">The term to unify</param>
            <param name="result">The resulting unified term</param>
            <returns><see langword="true"/> if the terms unify, <see langword="false"/> otherwise</returns>
        </member>
        <member name="P:Impulse.v_0_1.Variable.Binding">
            <summary>
            Gets or sets the bindings of this variable
            </summary>
        </member>
        <member name="T:Impulse.v_0_1.Literal">
            <summary>
            Class representing a literal
            </summary>
        </member>
        <member name="F:Impulse.v_0_1.Literal.LiteralRegex">
            <summary>
            The regular expression defining a literal
            </summary>
        </member>
        <member name="M:Impulse.v_0_1.Literal.#ctor(System.String)">
            <summary>
            Creates a literal with the specified name
            </summary>
            <param name="name">The name of the new literal</param>
        </member>
        <member name="M:Impulse.v_0_1.Literal.FromString(System.String)">
            <summary>
            Creates a literal from the specified string representation
            </summary>
            <param name="literal">The literal to parse</param>
            <returns>A literal object from the given literal string</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.ToString">
            <summary>
            Converts this literal into a string representation
            </summary>
            <returns>A strign representation of the literal</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.ToPrefixedString">
            <summary>
            Converts this string into a LISP style representation
            </summary>
            <returns>A LISP style list representing the literal</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.Equals(System.Object)">
            <summary>
            Determines if this literal is equal to a given object
            </summary>
            <param name="obj">The object to compare</param>
            <returns><see langword="true"/> if the objects are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.Equals(Impulse.v_0_1.Term)">
            <summary>
            Determines if this literal is equal to a given term
            </summary>
            <param name="term">The term to compare</param>
            <returns><see langword="true"/> if the terms are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.Equals(Impulse.v_0_1.Literal)">
            <summary>
            Determines if this literal is equal to another literal
            </summary>
            <param name="literal">The literal to compare</param>
            <returns><see langword="true"/> if the literals are equal, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.GetHashCode">
            <summary>
            Returns the hash code of this literal, which is the hash of its name
            </summary>
            <returns>The hash code of the literal</returns>
        </member>
        <member name="M:Impulse.v_0_1.Literal.Unify(Impulse.v_0_1.Term,Impulse.v_0_1.Term@)">
            <summary>
            Not implemented. Unifies this literal with another term
            </summary>
            <param name="term">The term to unify</param>
            <param name="result">The resulting unified term</param>
            <returns><see langword="true"/> if the terms unify, <see langword="false"/> otherwise</returns>
        </member>
        <member name="P:Impulse.v_0_1.Literal.Terms">
            <summary>
            Gets the list of terms of this literal
            </summary>
        </member>
        <member name="P:Impulse.v_0_1.Literal.Positive">
            <summary>
            Gets or sets whether this literal is positive
            </summary>
        </member>
        <member name="P:Impulse.v_0_1.Literal.LiteralText">
            <summary>
            Gets or sets the text representation of this literal
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ActionType">
            <summary>
            Class representing a story action type
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ActionType.#ctor(System.String,System.Collections.Generic.IEnumerable{Impulse.v_1_336.ActionPropertyDefinition})">
            <summary>
            Create a new story action type
            </summary>
            <param name="name">The name of the type</param>
            <param name="properties">The property definitions of the type</param>
        </member>
        <member name="M:Impulse.v_1_336.ActionType.GetProperty(System.String)">
            <summary>
            Get a named property
            </summary>
            <param name="name">The name of the property</param>
            <returns>The given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="M:Impulse.v_1_336.ActionType.TryGetProperty(System.String,Impulse.v_1_336.ActionPropertyDefinition@)">
            <summary>
            Try to get a named property
            </summary>
            <param name="name">The name of the property</param>
            <param name="property">The given property</param>
            <returns><see langword="true"/> if the given property was found</returns>
        </member>
        <member name="P:Impulse.v_1_336.ActionType.Name">
            <summary>
            Get the name of the type
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.ActionType.Properties">
            <summary>
            Get the property definitions of the type
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.AStory`3">
            <summary>
            An implementation of IStory using specific types for times, intervals, and the interval set
            </summary>
            <typeparam name="TTime">The type to use for times</typeparam>
            <typeparam name="TInterval">The type to use for intervals</typeparam>
            <typeparam name="TIntervalSet">The type to use for the interval set</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IStory">
            <summary>
            Interface representing a story
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.IStory.Query(Impulse.v_1_336.ISentence)">
            <summary>
            Query the set of variable mappings that makes the given sentence true
            </summary>
            <param name="sentence">The sentence query</param>
            <returns>A list of mappings that make the sentence true</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStory.Query(Impulse.v_1_336.IFunction)">
            <summary>
            Query the value of a function
            </summary>
            <param name="function">The function</param>
            <returns>The value of the function</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStory.Occurs(System.String)">
            <summary>
            Checks if a story action occurs in the story
            </summary>
            <param name="storyActionName">The name to query</param>
            <returns><see langword="true"/> if the action occurs in the story</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStory.TryGetAction(System.String,Impulse.v_1_336.IStoryAction@)">
            <summary>
            Checks if a story action occurs in the story
            </summary>
            <param name="storyActionName">The name to query</param>
            <param name="action">The found story action in the story</param>
            <returns><see langword="true"/> if the action occurs in the story</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStory.ToXmlStory">
            <summary>
            Turn the story into an XML representation
            </summary>
            <returns>An XML representation of the story</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStory.GenerateCausalGraph">
            <summary>
            Create a causal graph of the actions in the story
            </summary>
            <returns>A directed graph of the causal links</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStory.GeneratePDDL(LN.Planning.Domain@,LN.Planning.Problem@,LN.Planning.Plan@)">
            <summary>
            Use Impulse story to generate representative PDDL files
            </summary>
            <param name="domain"></param>
            <param name="problem"></param>
            <param name="plan"></param>
        </member>
        <member name="P:Impulse.v_1_336.IStory.Name">
            <summary>
            The name of the story
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.ActionTypeGraph">
            <summary>
            A graph of the names of action types where a directed edge A->B means B is a subtype of A
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.ObjectSetGraph">
            <summary>
            A graph of the names of object sets where a directed edge A->B means A contains B
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.ActionTypes">
            <summary>
            A dictionary of action names to action types
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.Actions">
            <summary>
            List of story actions
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.ObjectSets">
            <summary>
            Dictionary of object set names to object sets
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.Sentences">
            <summary>
            Collection of logical sentences
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStory.IntervalSet">
            <summary>
            The interval set of the story
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.GeneratePDDL(`0,LN.Planning.Domain@,LN.Planning.Problem@,LN.Planning.Plan@)">
            <summary>
            Use Impulse story to generate representative PDDL files
            </summary>
            <param name="domain"></param>
            <param name="problem"></param>
            <param name="plan"></param>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.#ctor(System.String,LN.Utilities.Collections.DirectedGraph{System.String,LN.Utilities.Collections.Edge{System.String}},System.Collections.Generic.IEnumerable{Impulse.v_1_336.ActionType},System.Collections.Generic.IEnumerable{Impulse.v_1_336.IStoryAction{`1}},System.Collections.Generic.IDictionary{System.String,Impulse.v_1_336.IObjectSet},System.Collections.Generic.IEnumerable{Impulse.v_1_336.ISentence},`2)">
            <summary>
            Create a new story
            </summary>
            <param name="name">The story name</param>
            <param name="actionTypeGraph">The action type graph</param>
            <param name="actionTypes">A list of action types</param>
            <param name="actions">A list of actions</param>
            <param name="objectSets">Dictionary of object sets</param>
            <param name="sentences">A list of sentences</param>
            <param name="intervalSet">The interval set</param>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.Query(Impulse.v_1_336.ISentence)">
            <summary>
            Query the set of variable mappings that makes the given sentence true
            </summary>
            <param name="sentence">The sentence query</param>
            <returns>A list of mappings that make the sentence true</returns>
            <remarks>NOT IMPLEMENTED</remarks>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.Query(Impulse.v_1_336.Sentences.IPredicate)">
            <summary>
            NOT IMPLEMENTED. Query the set of variable mappings that makes the given predicate true
            </summary>
            <param name="predicate">The predicate query</param>
            <returns>A list of mappings that make the predicate true</returns>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.Query(Impulse.v_1_336.IFunction)">
            <summary>
            Query the value of a function
            </summary>
            <param name="function">The function</param>
            <returns>The value of the function</returns>
            <remarks>IMPLEMENTED FOR ACTION PROPERTIES ONLY</remarks>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.GenerateCausalGraph">
            <summary>
            Create a causal graph of the actions in the story
            </summary>
            <returns>A directed graph of the causal links</returns>
        </member>
        <member name="M:Impulse.v_1_336.AStory`3.ToXmlStory">
            <summary>
            Turn the story into an XML representation
            </summary>
            <returns>An XML representation of the story</returns>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.Name">
            <summary>
            The name of the story
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.ActionTypeGraph">
            <summary>
            A graph of the names of action types where a directed edge A->B means B is a subtype of A
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.ObjectSetGraph">
            <summary>
            A graph of the names of object sets where a directed edge A->B means A contains B
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.ActionTypes">
            <summary>
            A dictionary of action names to action types
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.Actions">
            <summary>
            Dictionary of action names to actions
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.ObjectSets">
            <summary>
            Dictionary of object set names to object sets
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.Sentences">
            <summary>
            Collection of logical sentences
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStory`3.IntervalSet">
            <summary>
            The interval set of the story
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ConstantParsers">
            <summary>
            Static class containing built in constant parsers
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ConstantParsers.TryMakeParser``1(Impulse.v_1_336.IConstantParser{Impulse.v_1_336.Constants.ValueConstant{``0}}@)">
            <summary>
            Try to make a constant parser for a given type
            </summary>
            <typeparam name="T">The type to parse</typeparam>
            <param name="constantParser">The resulting constant parser, <see langword="null"/> if creation failed</param>
            <returns><see langword="true"/> if making the parser was successful</returns>
        </member>
        <member name="M:Impulse.v_1_336.ConstantParsers.HasParser(System.String)">
            <summary>
            Check if this class contains the specified parser
            </summary>
            <param name="name">The name to search for</param>
            <returns><see langword="true"/> if this class contains a parser with the given name</returns>
        </member>
        <member name="M:Impulse.v_1_336.ConstantParsers.GetParser(System.String)">
            <summary>
            Get a constant parser with the given name
            </summary>
            <param name="name">The name to search for</param>
            <returns>The specified parser</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the name was not found</exception>
        </member>
        <member name="M:Impulse.v_1_336.ConstantParsers.TryGetSet(System.String,Impulse.v_1_336.IConstantParser@)">
            <summary>
            Try to get a constant parser with the given name
            </summary>
            <param name="name">The name to search for</param>
            <param name="parser">The found parser, if any</param>
            <returns><see landword="true"/> if the parser was found</returns>
        </member>
        <member name="F:Impulse.v_1_336.ConstantParsers.All">
            <summary>
            An array of all the builtin parsers in this class of the form (name, parser)
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.BuiltinObjectSets">
            <summary>
            Static class encapsulating some built-in object sets
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinObjectSets.HasSet(System.String)">
            <summary>
            Checks if a given set is included in the built-in sets
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinObjectSets.GetSet(System.String)">
            <summary>
            Gets the object set with the specified name
            </summary>
            <param name="name">The name of the object set to get</param>
            <returns>An object set with the specified name</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If no set with the specified name exists</exception>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinObjectSets.TryGetSet(System.String,Impulse.v_1_336.IObjectSet@)">
            <summary>
            Gets the object set with the specified name
            </summary>
            <param name="name">The name of the object set to get</param>
            <param name="set">The found set</param>
            <returns><see langword="true"/> if the set was found</returns>
        </member>
        <member name="F:Impulse.v_1_336.BuiltinObjectSets.All">
            <summary>
            Array of all builtin sets in this class, <c>Item1</c> is the name and <c>Item2</c> is the set
            </summary>
            <remarks>Some sets appear more than once with aliases</remarks>
        </member>
        <member name="T:Impulse.v_1_336.BuiltinObjectSetAttribute">
            <summary>
            Attribute indicating that a static field contains a built-in object set
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinObjectSetAttribute.#ctor(System.String[])">
            <summary>
            Create a built-in object set attribute
            </summary>
            <param name="aliases">The list of alias to use for this object set</param>
        </member>
        <member name="P:Impulse.v_1_336.BuiltinObjectSetAttribute.Aliases">
            <summary>
            Get the list of alias for this built-in object set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.BuiltinConstantParserAttribute">
            <summary>
            Attribute indicating that a static field contains a built-in constant parser
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinConstantParserAttribute.#ctor(System.String[])">
            <summary>
            Create a built-in constant parser attribute
            </summary>
            <param name="aliases">The list of aliases for the sets this built-in constant parser parses</param>
        </member>
        <member name="P:Impulse.v_1_336.BuiltinConstantParserAttribute.ObjectSetAliases">
            <summary>
            Get the list of aliases for the sets this built-in constant parser parses
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ImpulseBuiltinsAttribute">
            <summary>
            Attribute indicating a class contains built-in constant parsers or object sets
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ImpulseBuiltinsAttribute.#ctor">
            <summary>
            Create a new built-in attribute
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.BuiltinsHelper">
            <summary>
            Static class for working with built-in attributes, constant parsers, and object sets
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinsHelper.LoadImpulseBuiltins``2(Impulse.v_1_336.StoryParsingFactory{``0,``1},System.Reflection.Assembly)">
            <summary>
            Load all impulse built-ins from a target assembly
            </summary>
            <typeparam name="TTime">The type of times in a parsing factory</typeparam>
            <typeparam name="TInterval">The type of intervals in a parsing factory</typeparam>
            <param name="factory">A story parsing factory to register the built-ins with</param>
            <param name="assembly">The target assembly to search</param>
        </member>
        <member name="M:Impulse.v_1_336.BuiltinsHelper.LoadBuiltins(System.Reflection.Assembly,System.Collections.Generic.IEnumerable{LN.Utilities.Tuple{System.String,Impulse.v_1_336.IConstantParser}}@,System.Collections.Generic.IEnumerable{LN.Utilities.Tuple{System.String,Impulse.v_1_336.IObjectSet}}@)">
            <summary>
            Load all impulse built-ins from a target assembly
            </summary>
            <param name="assembly">The assembly to search</param>
            <param name="parsers">The resulting list of parsers</param>
            <param name="sets">The resulting list of object sets</param>
        </member>
        <member name="T:Impulse.v_1_336.CausalLink">
            <summary>
            Class representing a causal link graph edge
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.CausalLink.#ctor(System.String,System.String,System.UInt32,System.UInt32)">
            <summary>
            Create a new causal link
            </summary>
            <param name="fromStepID">The from step ID</param>
            <param name="toStepID">The to step ID</param>
            <param name="fromIndex">The index of the from step effect</param>
            <param name="toIndex">The index of the to step precondition</param>
        </member>
        <member name="M:Impulse.v_1_336.CausalLink.TryParse(Impulse.v_1_336.Sentences.IPredicate,Impulse.v_1_336.CausalLink@)">
            <summary>
            Try to parse a caual link from a cause predicate
            </summary>
            <param name="predicate">The cause predicate of the form cause(fromID, toID, fromIndex, toIndex)</param>
            <param name="causalLink">The resulting causal link, if any</param>
            <returns><see langword="true"/> if parsing was successful</returns>
        </member>
        <member name="M:Impulse.v_1_336.CausalLink.TryParse(Impulse.v_1_336.Sentences.IPredicate)">
            <summary>
            Try to parse a caual link from a cause predicate
            </summary>
            <param name="predicate">The cause predicate of the form cause(fromID, toID, fromIndex, toIndex)</param>
            <returns>The resulting causal link, if parsing was successful, <see langword="null"/> otherwise</returns>
        </member>
        <member name="P:Impulse.v_1_336.CausalLink.FromStepID">
            <summary>
            Get the from step ID
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.CausalLink.ToStepID">
            <summary>
            Get the to step ID
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.CausalLink.FromIndex">
            <summary>
            Get the index of the from step effect
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.CausalLink.ToIndex">
            <summary>
            Get the index of the to step precondition
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.SetConstant`1">
            <summary>
            Standard implementation of a constant containing a set of constants
            </summary>
            <typeparam name="TConstant">The constant type to contain</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IConstant`1">
            <summary>
            Class representing a constant encapsulating a specific type
            </summary>
            <typeparam name="T">The type to encapsulate</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IConstant">
            <summary>
            Class representing a constant
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ITerm">
            <summary>
            A general term for use in logical sentences
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.ITerm.Name">
            <summary>
            The name of the term
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IConstant.Value">
            <summary>
            Gets the value of this constant
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IConstant`1.Value">
            <summary>
            Gets the value of this constant
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IFiniteObjectSet`1">
            <summary>
            A finite object set of a specific type of constants
            </summary>
            <typeparam name="TConstant">The type of constants this set contains</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IFiniteObjectSet">
            <summary>
            A finite object set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IObjectSet">
            <summary>
            Interface for a set of objects
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.IObjectSet.Contains(Impulse.v_1_336.IConstant)">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.IObjectSet.IsSubsetOf(Impulse.v_1_336.IObjectSet)">
            <summary>
            Checks if this set is a subset of another set
            </summary>
            <param name="other">The set to check against</param>
            <returns><see langword="true"/> if this set is a subset of other</returns>
        </member>
        <member name="P:Impulse.v_1_336.IObjectSet.Name">
            <summary>
            Get the name of this set
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IFiniteObjectSet.Count">
            <summary>
            Get the number of constants in this set
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IFiniteObjectSet.Items">
            <summary>
            An enumeration of the constants in this set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IObjectSet`1">
            <summary>
            An object set of a specific type of constants
            </summary>
            <typeparam name="TConstant">The type of constants this set contains</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.IObjectSet`1.Contains(`0)">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.#ctor(`0[])">
            <summary>
            Create a new set constant
            </summary>
            <param name="values">A set of constants, may not be <see langword="null"/></param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.GetHashCode">
            <summary>
            Get the hash code of this constant
            </summary>
            <returns>A hash code based on the values of this constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.Equals(System.Object)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if obj is an IConstant&lt;TConstant[]&gt; with equal values</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if the term is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal values</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.Equals(Impulse.v_1_336.Constants.SetConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constants have equal values</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.Equals(Impulse.v_1_336.IConstant{`0[]})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if both constants have equal values</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.Equals(Impulse.v_1_336.IConstant)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constant is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal values</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.SetConstant`1.ToString">
            <summary>
            Generate a string representation of this constants values
            </summary>
            <returns>A string representation of this constants values</returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.SetConstant`1.Values">
            <summary>
            Get the set of values of this constant
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.ConstantDelegateParser`1">
            <summary>
            Standard implementation of a parser based on a single <see cref="T:TryParseConstant"/> TryParse function
            </summary>
            <typeparam name="TConstant">The type of constant to parse</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IConstantParser`1">
            <summary>
            Interface for a constant parser with a specific constant type
            </summary>
            <typeparam name="TConstant">The type of constant to be parsed</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IConstantParser">
            <summary>
            Interface for a constant parser
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser.CanParse(System.String)">
            <summary>
            Check if a string can be parsed successfully
            </summary>
            <param name="value">The string to parse</param>
            <returns><see langword="true"/> if the string can be parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser.TryParse(System.String,Impulse.v_1_336.IConstant@)">
            <summary>
            Try to parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <param name="constant">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser.Parse(System.String)">
            <summary>
            Parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <returns>The resulting constant</returns>
            <exception cref="T:System.ArgumentException">If the string cannot be parsed successfully</exception>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser.ToActionProperty(System.String,Impulse.v_1_336.IConstant,Impulse.v_1_336.IObjectSet,System.Boolean)">
            <summary>
            Turn a constant into an action property
            </summary>
            <param name="name">The name of the property</param>
            <param name="constant">The constant to encapsulate</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>>
            <returns>A new action property</returns>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser`1.TryParse(System.String,`0@)">
            <summary>
            Try to parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <param name="constant">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser`1.Parse(System.String)">
            <summary>
            Parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <returns>The resulting constant</returns>
            <exception cref="T:System.ArgumentException">If the string cannot be parsed successfully</exception>
        </member>
        <member name="M:Impulse.v_1_336.IConstantParser`1.ToActionProperty(System.String,`0,Impulse.v_1_336.IObjectSet{`0},System.Boolean)">
            <summary>
            Turn a constant into an action property
            </summary>
            <param name="name">The name of the property</param>
            <param name="constant">The constant to encapsulate</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>
            <returns>A new action property</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantDelegateParser`1.#ctor(System.String,Impulse.v_1_336.Constants.TryParseConstant{`0})">
            <summary>
            Create a new delegate constant parser
            </summary>
            <param name="pattern">The pattern the input should be in for parsing, only used for describing parser failure</param>
            <param name="parser">A function that tries to parse the constant type, must not be <see langword="null"/></param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantDelegateParser`1.TryParse(System.String,`0@)">
            <summary>
            Try to parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <param name="constant">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantDelegateParser`1.Parse(System.String)">
            <summary>
            Parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <returns>The resulting constant</returns>
            <exception cref="T:System.ArgumentException">If the string cannot be parsed successfully</exception>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantDelegateParser`1.CanParse(System.String)">
            <summary>
            Check if a string can be parsed successfully
            </summary>
            <param name="value">The string to parse</param>
            <returns><see langword="true"/> if the string can be parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantDelegateParser`1.TryParse(System.String,Impulse.v_1_336.IConstant@)">
            <summary>
            Try to parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <param name="constant">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantDelegateParser`1.ToActionProperty(System.String,`0,Impulse.v_1_336.IObjectSet{`0},System.Boolean)">
            <summary>
            Turn a constant into an action property
            </summary>
            <param name="name">The name of the property</param>
            <param name="constant">The constant to encapsulate</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>
            <returns>A new action property</returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.ConstantDelegateParser`1.Pattern">
            <summary>
            Get the pattern associated with this parser
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.Coordinate3D">
            <summary>
            Class representing an x,y,z-coordinate as a 3-tuple of doubles
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Constants.Coordinate3D.Regex">
            <summary>
            The regular expression used for parsing coordinates, roughly (x,y,z)
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Constants.Coordinate3D.NullableRegex">
            <summary>
            The regular expression used for parsing nullable coordinates, roughly null or (x,y,z)
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new coordinate
            </summary>
            <param name="x">The X coordinate</param>
            <param name="y">The Y coordinate</param>
            <param name="z">The Z coordinate</param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate3D.TryParse(System.String,Impulse.v_1_336.Constants.Coordinate3D@)">
            <summary>
            Try to parse a coordinate
            </summary>
            <param name="input">The input representing a coordinate</param>
            <param name="coordinate">The resulting coordinate, if successful</param>
            <returns><see langword="true"/> if parsing was successful</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate3D.Equals(Impulse.v_1_336.Constants.Coordinate3D)">
            <summary>
            Check if this coordinate is equal to another
            </summary>
            <param name="other">The coordinate to compare to</param>
            <returns><see langword="true"/> if the coordinates have the same X, Y, and Z coordinates</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate3D.Equals(System.Object)">
            <summary>
            Check if this coordinate is equal to another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if the object is a coordinate and has the same X, Y, and Z coordinates</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate3D.GetHashCode">
            <summary>
            Generate a hash code for this coordinate
            </summary>
            <returns>A hash of this coordinate</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate3D.ToString">
            <summary>
            Create a string parse-able representation of this coordinate
            </summary>
            <returns>A parse-able representation of this coordinate</returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.Coordinate3D.X">
            <summary>
            Get the X coordinate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Constants.Coordinate3D.Y">
            <summary>
            Get the Y coordinate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Constants.Coordinate3D.Z">
            <summary>
            Get the Z coordinate
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.ParseConstant`1">
            <summary>
            Parse a given string
            </summary>
            <typeparam name="TConstant">The type of TConstant to produce</typeparam>
            <param name="groups">The groups from <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String)"/> successfully matching</param>
            <returns>The resulting constant</returns>
        </member>
        <member name="T:Impulse.v_1_336.Constants.TryParseConstant`1">
            <summary>
            Try to parse a given string
            </summary>
            /// <typeparam name="TConstant">The type of TConstant to produce</typeparam>
            <param name="input">The string to parse</param>
            <param name="value">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="T:Impulse.v_1_336.Constants.StringConstantParser">
            <summary>
            Standard implementation of a string parser
            </summary>
            <remarks>This is just a pass-through parser so there is only one instance</remarks>
        </member>
        <member name="F:Impulse.v_1_336.Constants.StringConstantParser.Instance">
            <summary>
            Get the only instance of a string constant parser
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Constants.StringConstantParser.Parse(System.String)">
            <summary>
            Create a new string constant with the given string
            </summary>
            <param name="value">The string value of the new constant</param>
            <returns>A new string constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.StringConstantParser.ToActionProperty(System.String,Impulse.v_1_336.Constants.ClassConstant{System.String},Impulse.v_1_336.IObjectSet{Impulse.v_1_336.Constants.ClassConstant{System.String}},System.Boolean)">
            <summary>
            Turn a constant into an action property
            </summary>
            <param name="name">The name of the property</param>
            <param name="constant">The constant to encapsulate</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>
            <returns>A new action property</returns>
        </member>
        <member name="T:Impulse.v_1_336.Constants.ConstantRegexParser`1">
            <summary>
            Standard implementation of a parser based on a regular expression
            </summary>
            <typeparam name="TConstant">The type of constant to parse</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantRegexParser`1.#ctor(System.Text.RegularExpressions.Regex,Impulse.v_1_336.Constants.ParseConstant{`0})">
            <summary>
            Create a new regular expression constant parser
            </summary>
            <param name="regex">The regular expression object to use for parsing, must not be <see langword="null"/></param>
            <param name="parser">A function that takes in the groups from the regular expression and creates a new constant, must not be <see langword="null"/></param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantRegexParser`1.TryParse(System.String,`0@)">
            <summary>
            Try to parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <param name="constant">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantRegexParser`1.Parse(System.String)">
            <summary>
            Parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <returns>The resulting constant</returns>
            <exception cref="T:System.ArgumentException">If the string cannot be parsed successfully</exception>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantRegexParser`1.CanParse(System.String)">
            <summary>
            Check if a string can be parsed successfully
            </summary>
            <param name="value">The string to parse</param>
            <returns><see langword="true"/> if the string can be parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantRegexParser`1.TryParse(System.String,Impulse.v_1_336.IConstant@)">
            <summary>
            Try to parse a given string
            </summary>
            <param name="value">The string to parse</param>
            <param name="constant">The resulting constant, if any</param>
            <returns><see langword="true"/> if the string was parsed successfully</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ConstantRegexParser`1.ToActionProperty(System.String,`0,Impulse.v_1_336.IObjectSet{`0},System.Boolean)">
            <summary>
            Turn a constant into an action property
            </summary>
            <param name="name">The name of the property</param>
            <param name="constant">The constant to encapsulate</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>
            <returns>A new action property</returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.ConstantRegexParser`1.Regex">
            <summary>
            Get the regular expression object used by this parser
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.NullableConstant`1">
            <summary>
            Standard implementation of a nullable value type constant
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.#ctor(System.Nullable{`0})">
            <summary>
            Create a new nullable value type constant
            </summary>
            <param name="value">The value of this constant</param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.GetHashCode">
            <summary>
            Get the hash code of this constant
            </summary>
            <returns>A hash code based on the value of this constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.Equals(System.Object)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if obj is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.Equals(Impulse.v_1_336.Constants.NullableConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constants have equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if the term is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.Equals(Impulse.v_1_336.IConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if both constants have equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.Equals(Impulse.v_1_336.IConstant)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constant is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.NullableConstant`1.ToString">
            <summary>
            Generate a string representation of this constants value
            </summary>
            <returns>A string representation of this constants value</returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.NullableConstant`1.Value">
            <summary>
            Get the nullable value of this constant
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.ValueConstant`1">
            <summary>
            Standard implementation of a value type constant
            </summary>
            <typeparam name="T">The value type to encapsulate</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.#ctor(`0)">
            <summary>
            Create a new constant with the specified value
            </summary>
            <param name="value">The value of this constant</param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.GetHashCode">
            <summary>
            Get the hash code of this constant
            </summary>
            <returns>A hash code based on the value of this constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.Equals(System.Object)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if obj is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.Equals(Impulse.v_1_336.Constants.ValueConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constants have equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if the term is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.Equals(Impulse.v_1_336.IConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if both constants have equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.Equals(Impulse.v_1_336.IConstant)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constant is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ValueConstant`1.ToString">
            <summary>
            Generate a string representation of this constants value
            </summary>
            <returns><code>this.Value.ToString()</code></returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.ValueConstant`1.Value">
            <summary>
            Get the value of this constant
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.ClassConstant`1">
            <summary>
            Standard implementation of a reference type constant
            </summary>
            <typeparam name="T">The reference type to encapsulate</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.#ctor(`0)">
            <summary>
            Create a new constant with the specified value
            </summary>
            <param name="value">The value of this constant</param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.GetHashCode">
            <summary>
            Get the hash code of this constant
            </summary>
            <returns>A hash code based on the value of this constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.Equals(System.Object)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if obj is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if the term is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.Equals(Impulse.v_1_336.Constants.ClassConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constants have equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.Equals(Impulse.v_1_336.IConstant{`0})">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if both constants have equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.Equals(Impulse.v_1_336.IConstant)">
            <summary>
            Check if this constant equals another
            </summary>
            <param name="other">The constant to compare to</param>
            <returns><see langword="true"/> if the constant is an <see cref="T:Impulse.v_1_336.IConstant`1"/> with equal value</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.ClassConstant`1.ToString">
            <summary>
            Generate a string representation of this constants value
            </summary>
            <returns><code>this.Value.ToString()</code></returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.ClassConstant`1.Value">
            <summary>
            Get the value of this constant
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Constants.Coordinate2D">
            <summary>
            Class representing an x,y-coordinate as a pair of doubles
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Constants.Coordinate2D.Regex">
            <summary>
            The regular expression used for parsing coordinates
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Constants.Coordinate2D.NullableRegex">
            <summary>
            The regular expression used for parsing nullable coordinates
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate2D.#ctor(System.Double,System.Double)">
            <summary>
            Create a new coordinate
            </summary>
            <param name="x">The X coordinate</param>
            <param name="y">The Y coordinate</param>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate2D.TryParse(System.String,Impulse.v_1_336.Constants.Coordinate2D@)">
            <summary>
            Try to parse a coordinate
            </summary>
            <param name="input">The input representing a coordinate</param>
            <param name="coordinate">The resulting coordinate, if successful</param>
            <returns><see langword="true"/> if parsing was successful</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate2D.Equals(Impulse.v_1_336.Constants.Coordinate2D)">
            <summary>
            Check if this coordinate is equal to another
            </summary>
            <param name="other">The coordinate to compare to</param>
            <returns><see langword="true"/> if the coordinates have the same X and Y coordinates</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate2D.Equals(System.Object)">
            <summary>
            Check if this coordinate is equal to another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if the object is a coordinate and has the same X and Y coordinates</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate2D.GetHashCode">
            <summary>
            Generate a hash code for this coordinate
            </summary>
            <returns>A hash of this coordinate</returns>
        </member>
        <member name="M:Impulse.v_1_336.Constants.Coordinate2D.ToString">
            <summary>
            Create a string parse-able representation of this coordinate
            </summary>
            <returns>A parse-able representation of this coordinate</returns>
        </member>
        <member name="P:Impulse.v_1_336.Constants.Coordinate2D.X">
            <summary>
            Get the X coordinate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Constants.Coordinate2D.Y">
            <summary>
            Get the Y coordinate
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ConstantParserExtensions">
            <summary>
            Extension methods for constant parsers
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ConstantParserExtensions.ToActionProperty(Impulse.v_1_336.IConstantParser,Impulse.v_1_336.IObjectSet,System.String,System.String,System.Boolean)">
            <summary>
            Create an action property
            </summary>
            <param name="parser">The parser to use</param>
            <param name="name">The name of the property</param>
            <param name="value">The value to parse</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>
            <returns>A new action property</returns>
        </member>
        <member name="M:Impulse.v_1_336.ConstantParserExtensions.ToActionProperty``1(Impulse.v_1_336.IConstantParser{``0},Impulse.v_1_336.IObjectSet{``0},System.String,System.String,System.Boolean)">
            <summary>
            Create an action property
            </summary>
            <typeparam name="TConstant">The type of constant to parse</typeparam>
            <param name="parser">The parser to use</param>
            <param name="name">The name of the property</param>
            <param name="value">The value to parse</param>
            <param name="range">The range of the constant to encapsulate</param>
            <param name="verify"><see langword="true"/> to verify that range contains the constant</param>
            <returns>A new action property</returns>
        </member>
        <member name="T:Impulse.v_1_336.IIntervalSet">
            <summary>
            Interface describing a set of intervals
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.IIntervalSet.IsTime(Impulse.v_1_336.IConstant)">
            <summary>
            Check if a constant is a valid time constant
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the constant is a valid time</returns>
        </member>
        <member name="M:Impulse.v_1_336.IIntervalSet.Compare(Impulse.v_1_336.IConstant,Impulse.v_1_336.IConstant)">
            <summary>
            Compares two times
            </summary>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns>-1 of <c>left &lt; right</c>, 0 if <c>left == right</c>, and 1 if <c>left &gt; right</c></returns>
        </member>
        <member name="T:Impulse.v_1_336.IIntervalSet`2">
            <summary>
            Interface describing a set of intervals with specific types
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.IIntervalSet`2.IsTime(`0)">
            <summary>
            Check if a constant is a valid time constant
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the constant is a valid time</returns>
        </member>
        <member name="M:Impulse.v_1_336.IIntervalSet`2.Compare(`0,`0)">
            <summary>
            Compares two times
            </summary>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns>-1 of <c>left &lt; right</c>, 0 if <c>left == right</c>, and 1 if <c>left &gt; right</c></returns>
        </member>
        <member name="T:Impulse.v_1_336.IntervalSetExtensions">
            <summary>
            Extension methods for IntervalSets that define all the temporal relations
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.TemporalRelation``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1,Impulse.v_1_336.Xml.RelationType)">
            <summary>
            Check if any of the given temporal relation holds between two intervals
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <param name="type">A flags enumeration of relations to check via a logical OR</param>
            <returns><see langword="true"/> if any of the relations in the flags holds</returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.EqualTo``2(Impulse.v_1_336.IIntervalSet{``0,``1},``0,``0)">
            <summary>
            Check if two times are equal
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left == right</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.GreaterThan``2(Impulse.v_1_336.IIntervalSet{``0,``1},``0,``0)">
            <summary>
            Check if one time is greater than another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left &gt; right</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.LessThan``2(Impulse.v_1_336.IIntervalSet{``0,``1},``0,``0)">
            <summary>
            Check if one time is less than another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left &lt; right</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.GreaterThanOrEqualTo``2(Impulse.v_1_336.IIntervalSet{``0,``1},``0,``0)">
            <summary>
            Check if one time is greater than or equal to another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left >= right</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.LessThanOrEqualTo``2(Impulse.v_1_336.IIntervalSet{``0,``1},``0,``0)">
            <summary>
            Check if one time is less than or equal to another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left &lt;= right</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.After``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is after another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>right.End &lt; left.Start</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Before``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is before another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>right.End &lt; left.Start</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Contains``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is contains another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start &lt; right.Start &amp;&amp;left.End &gt; right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.During``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is during another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start &gt; right.Start &amp;&amp;left.End &lt; right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.EqualTo``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is equal to another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start == right.Start &amp;&amp;left.End == right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Finishes``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval finishes another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start &gt; right.Start &amp;&amp;left.End == right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.IsFinishedBy``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is finished by another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start &lt; right.Start &amp;&amp;left.End == right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.IsMetBy``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is met by another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start == right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.IsOverlappedBy``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is overlapped by another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>right.Start &lt; left.Start &amp;&amp;left.Start &lt; right.End &amp;&amp;right.End &lt; left.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.IsStartedBy``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is started by another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start == right.Start &amp;&amp;left.End &gt; right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Meets``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is met by another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.End == right.Start</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Overlaps``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is overlaps another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start &lt; right.Start &amp;&amp;right.Start &lt; left.End &amp;&amp;left.End &lt; right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Precedes``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval precedes another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.End &lt;= right.Start</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Starts``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval starts another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start == right.Start &amp;&amp;left.End &lt; right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Subinterval``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval is a subinterval of another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>right.Start &lt;= left.Start &amp;&amp;left.End &lt;= right.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.IncludesOrMeetsStartOf``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if one interval includes or meets the start of another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if <c>left.Start &lt;= right.Start &amp;&amp;right.Start &lt;= left.End</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.IntervalSetExtensions.Intersect``2(Impulse.v_1_336.IIntervalSet{``0,``1},``1,``1)">
            <summary>
            Check if two intervals intersect one another
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="TInterval">The type of intervals</typeparam>
            <param name="set">The set of intervals</param>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns><see langword="true"/> if left and right share a nonempty subinterval</returns>
        </member>
        <member name="T:Impulse.v_1_336.Interval`2">
            <summary>
            Standard implementation of an interval with a specific type for times
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="T">The type times wrap</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IInterval`1">
            <summary>
            Class representing an interval between two constants of a specific type
            </summary>
            <typeparam name="TConstant">The type of endpoints</typeparam>
        </member>
        <member name="T:Impulse.v_1_336.IInterval">
            <summary>
            Class representing an interval between two constants
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IInterval`1.Start">
            <summary>
            Get the start of this interval
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IInterval`1.End">
            <summary>
            Get the end of this interval
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.#ctor(`0,`0)">
            <summary>
            Create a new interval
            </summary>
            <param name="start">The start of the interval</param>
            <param name="end">The end of the interval</param>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.Equals(System.Object)">
            <summary>
            Check if this interval equals another
            </summary>
            <param name="obj">The obj to compare to</param>
            <returns><see langword="true"/> if obj is an interval with equal start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.GetHashCode">
            <summary>
            Get the hash code for this interval
            </summary>
            <returns>A hash based on the start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.ToString">
            <summary>
            Gets a parseable string representation of this interval
            </summary>
            <returns>A parseable string representation of this interval</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check if this interval equals another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if term is an interval with equal start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.Equals(Impulse.v_1_336.IInterval)">
            <summary>
            Check if this interval equals another
            </summary>
            <param name="other">The interval to compare to</param>
            <returns><see langword="true"/> if the intervals have equal start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.Equals(Impulse.v_1_336.IInterval{Impulse.v_1_336.IConstant{`1}})">
            <summary>
            Check if this interval equals another
            </summary>
            <param name="other">The interval to compare to</param>
            <returns><see langword="true"/> if the intervals have equal start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.Equals(Impulse.v_1_336.Interval{`0,`1})">
            <summary>
            Check if this interval equals another
            </summary>
            <param name="other">The interval to compare to</param>
            <returns><see langword="true"/> if the intervals have equal start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.Equals(Impulse.v_1_336.IInterval{`0})">
            <summary>
            Check if this interval equals another
            </summary>
            <param name="other">The interval to compare to</param>
            <returns><see langword="true"/> if the intervals have equal start and end times</returns>
        </member>
        <member name="M:Impulse.v_1_336.Interval`2.MakeParser(Impulse.v_1_336.IConstantParser{`0},System.String)">
            <summary>
            Create a new interval parser with given separator and time parser
            </summary>
            <param name="timeParser">The parser for times</param>
            <param name="separator">The separator for times</param>
            <returns>A new interval parser</returns>
        </member>
        <member name="P:Impulse.v_1_336.Interval`2.Start">
            <summary>
            The start of this interval
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Interval`2.End">
            <summary>
            The end of this interval
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Intervals.IntervalSets">
            <summary>
            Static class for helping in the construction of interval sets
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSets.MakeIntervalSet``2(System.String)">
            <summary>
            Make a default interval set with a given name and types
            </summary>
            <typeparam name="TTime">The type to use for times</typeparam>
            <typeparam name="TInterval">The type to use for intervals</typeparam>
            <param name="name">The name of the set</param>
            <returns>An interval set where all TTime are times and TTime.CompareTo is used for comparisons</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSets.MakeIntervalSet``3(System.String)">
            <summary>
            Make a default interval set with a given name and types
            </summary>
            <typeparam name="T">The type that TTime contains</typeparam>
            <typeparam name="TTime">The type to use for times</typeparam>
            <typeparam name="TInterval">The type to use for intervals</typeparam>
            <param name="name">The name of the set</param>
            <returns>An interval set where all TTime are times and T.CompareTo is used for comparisons</returns>
        </member>
        <member name="F:Impulse.v_1_336.Intervals.IntervalSets.UnsignedIntegerIntervals">
            <summary>
            Set of unsigned integer intervals
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Intervals.IntervalSet`2">
            <summary>
            Standard interval set implementation
            </summary>
            <typeparam name="TTime"></typeparam>
            <typeparam name="TInterval"></typeparam>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.#ctor(System.String,System.Func{`0,System.Boolean},System.Func{`0,`0,System.Int32})">
            <summary>
            Construct a new interval set
            </summary>
            <param name="name">The name of the set</param>
            <param name="isTime">A function to check if a time is valid</param>
            <param name="compare">A function to compare times</param>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.IsTime(`0)">
            <summary>
            Check if the given constant is a valid time
            </summary>
            <param name="constant">The constant time to check</param>
            <returns><see langword="true"/> if the constant is a valid time</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.Compare(`0,`0)">
            <summary>
            Compares two times
            </summary>
            <param name="left">The left-hand side</param>
            <param name="right">The right-hand side</param>
            <returns>-1 of <c>left &lt; right</c>, 0 if <c>left == right</c>, and 1 if <c>left > right</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.Equals(Impulse.v_1_336.IObjectSet)">
            <summary>
            Check if this interval set is equal to another
            </summary>
            <param name="other">The object set to compare to</param>
            <returns><see langword="true"/> if other is an interval set with the same types, membership constraints, and time comparison</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.Equals(System.Object)">
            <summary>
            Check if this interval set is equal to another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if obj is an interval set with the same types, membership constraints, and time comparison</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.Equals(Impulse.v_1_336.Intervals.IntervalSet{`0,`1})">
            <summary>
            Check if this interval set is equal to another
            </summary>
            <param name="other">The object set to compare to</param>
            <returns><see langword="true"/> if other has the same types, membership constraints, and time comparison</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.GetHashCode">
            <summary>
            Get the hash code for this interval set
            </summary>
            <returns>A hash code for this interval set</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.Contains(`1)">
            <summary>
            Check if an interval is a member of this set
            </summary>
            <param name="constant">The interval to check</param>
            <returns><see langword="true"/> if the intervals start compares to its end as &lt; 0</returns>
        </member>
        <member name="M:Impulse.v_1_336.Intervals.IntervalSet`2.ToString">
            <summary>
            Get a string representation of this interval set
            </summary>
            <returns>A string representation of this interval set</returns>
        </member>
        <member name="P:Impulse.v_1_336.Intervals.IntervalSet`2.Name">
            <summary>
            The name of this interval set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ObjectSets.ActionSet">
            <summary>
            Class representing the set of actions in a story action type
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.ActionSet.#ctor(System.String,LN.Utilities.Collections.IReadOnlyDirectedGraph{System.String,LN.Utilities.Collections.Edge{System.String}},System.Func{System.String,Impulse.v_1_336.IStoryAction})">
            <summary>
            Create a new action set
            </summary>
            <param name="name">The story action type name this set represents</param>
            <param name="actionTypeGraph">The story action type graph</param>
            <param name="getAction">A function that given a story action ID, returns the corresponding story action (if any)</param>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.ActionSet.Contains(Impulse.v_1_336.Constants.ClassConstant{System.String})">
            <summary>
            Check if this action type contains a given action
            </summary>
            <param name="constant">The action to check</param>
            <returns><see langword="true"/> if the action is an instance of this type</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.ActionSet.Contains(Impulse.v_1_336.IConstant)">
            <summary>
            Check if this action type contains a given action
            </summary>
            <param name="constant">The action to check</param>
            <returns><see langword="true"/> if the constant is a string constant representing an action and is an instance of this action type</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.ActionSet.IsSubsetOf(Impulse.v_1_336.IObjectSet)">
            <summary>
            Check if this set is a subset of another
            </summary>
            <param name="other">The set to check against</param>
            <returns><see langword="true"/> if other is an action type containing this type, or is the set of all objects</returns>
        </member>
        <member name="P:Impulse.v_1_336.ObjectSets.ActionSet.Name">
            <summary>
            Get the name of this action set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1">
            <summary>
            Standard implementation of a finite object set
            </summary>
            <typeparam name="TConstant">The type of constants to contain</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.#ctor(System.String)">
            <summary>
            Create a new finite object set with the given name
            </summary>
            <param name="name">The name of this set</param>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new finite object set with given name and items
            </summary>
            <param name="name">The name of this set</param>
            <param name="items">THe initial set of items in this set</param>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Add(`0)">
            <summary>
            Add a constant to this set
            </summary>
            <param name="item">The constant to add</param>
            <returns><see langword="true"/> if constant was not already in this set</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Clear">
            <summary>
            Clear all items from this set
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Contains(`0)">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="item">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy all the items in this set to an array
            </summary>
            <param name="array">The destination array</param>
            <param name="arrayIndex">The destination array starting index</param>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Remove(`0)">
            <summary>
            Remove a constant from this set
            </summary>
            <param name="item">The constant to remove</param>
            <returns><see langword="true"/> if this set contained the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.GetEnumerator">
            <summary>
            Get an enumerator for this set
            </summary>
            <returns>An enumerator for this set</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Contains(Impulse.v_1_336.IConstant)">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.IsSubsetOf(Impulse.v_1_336.IObjectSet)">
            <summary>
            Checks if this set is a subset of another set
            </summary>
            <param name="other">The set to check against</param>
            <returns><see langword="true"/> if all items in this set are items of other</returns>
        </member>
        <member name="P:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Name">
            <summary>
            Get the name of this set
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.ObjectSets.FiniteObjectSet`1.Count">
            <summary>
            Get the number of constants in this set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ObjectSets.PowerSet">
            <summary>
            Class representing a power set of another object set
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.PowerSet.#ctor(System.String,Impulse.v_1_336.IObjectSet)">
            <summary>
            Create a new power set based on another set
            </summary>
            <param name="baseName">Name of the base set</param>
            <param name="baseSet">The base object set</param>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.PowerSet.Contains(Impulse.v_1_336.IConstant{System.Collections.Generic.IEnumerable{Impulse.v_1_336.IConstant}})">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.PowerSet.Contains(Impulse.v_1_336.Constants.SetConstant{Impulse.v_1_336.IConstant})">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.PowerSet.Contains(Impulse.v_1_336.IConstant)">
            <summary>
            Checks if a given constant is a member of this set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the set contains the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.PowerSet.IsSubsetOf(Impulse.v_1_336.IObjectSet)">
            <summary>
            Checks if this set is a subset of another set
            </summary>
            <param name="other">The set to check against</param>
            <returns><see langword="false"/></returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSets.PowerSet.MakeParser(Impulse.v_1_336.IConstantParser)">
            <summary>
            Create a parser for members of the power set based on a parser for the base set items
            </summary>
            <param name="baseParser">The parser for the base set</param>
            <returns>A new parser for this power set</returns>
        </member>
        <member name="P:Impulse.v_1_336.ObjectSets.PowerSet.Name">
            <summary>
            Get the name of this set
            </summary>
            <remarks>Takes the form P(&lt;base-set-name&gt;)</remarks>
        </member>
        <member name="P:Impulse.v_1_336.ObjectSets.PowerSet.BaseSet">
            <summary>
            Get the base object set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Reflection.ActionTypeGenerator">
            <summary>
            Static class for generating C# action types from a story for use in parsing
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Reflection.ActionTypeGenerator.GenerateActionTypeClasses``1(Impulse.v_1_336.Xml.Story,System.String,System.IO.DirectoryInfo)">
            <summary>
            Create C# action type code for the types in the specified story
            </summary>
            <typeparam name="TInterval">The type to use as an interval type</typeparam>
            <param name="storyXml">The story XML</param>
            <param name="domainName">The name of the domain</param>
            <param name="info">The directory to write the output files to</param>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.IModality">
            <summary>
            Interface representing a modality
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ISentence">
            <summary>
            Interface representing a logical sentence
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ISentence.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.ISentence.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IModality.Actor">
            <summary>
            Get the actor of this modality
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IModality.Time">
            <summary>
            Get the time of this modality
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IModality.Sentence">
            <summary>
            Get the sentence of this modality
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IModality.Type">
            <summary>
            Get the type of this modality
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.ModalityType">
            <summary>
            Types of modality
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ModalityType.B">
            <summary>
            Belief
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ModalityType.D">
            <summary>
            Desire
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ModalityType.I">
            <summary>
            Intention
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ModalityType.CBA">
            <summary>
            Can Bring About
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.Modality">
            <summary>
            Standard implementation of a modality
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Modality.#ctor(System.String,Impulse.v_1_336.ITerm,Impulse.v_1_336.ITerm,Impulse.v_1_336.ISentence,Impulse.v_1_336.Sentences.ModalityType)">
            <summary>
            Create a new modality
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="actor">The actor of this modality</param>
            <param name="time">The time of this modality</param>
            <param name="sentence">The sentence of this modality</param>
            <param name="type">The type of this modality</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Modality.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Modality.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Modality.Type">
            <summary>
            Get the type of this modality
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Modality.Actor">
            <summary>
            Get the actor of this modality
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Modality.Time">
            <summary>
            Get the time of this modality
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Modality.Sentence">
            <summary>
            Get the sentence of this modality
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.IQuantifier">
            <summary>
            Logical quantification
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IQuantifier.Variable">
            <summary>
            Get the variable of this quantification
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IQuantifier.Set">
            <summary>
            Get the object set being quantified over
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IQuantifier.Sentence">
            <summary>
            Get the sentence of this quantification
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.QuantifierType">
            <summary>
            Types of logical quantification
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.QuantifierType.Exists">
            <summary>
            There exists at least one variable
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.QuantifierType.Forall">
            <summary>
            For every variable
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.Quantifier">
            <summary>
            A standard implementation of a logical quantification
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Quantifier.#ctor(System.String,Impulse.v_1_336.Variable,Impulse.v_1_336.ISentence,Impulse.v_1_336.Sentences.QuantifierType)">
            <summary>
            Create a new quantification
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="variable">The variable of this quantification</param>
            <param name="sentence">The sentence of this quantification</param>
            <param name="type">The type of quantification</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Quantifier.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Quantifier.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Quantifier.Type">
            <summary>
            Get the quantifier type of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Quantifier.Variable">
            <summary>
            Get the variable of this quantification
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Quantifier.Set">
            <summary>
            Get the object set being quantified over
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Quantifier.Sentence">
            <summary>
            Get the sentence of this quantification
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.ElementOf">
            <summary>
            Struct representing an element of relation
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.IBinaryRelation">
            <summary>
            Interface representing a binary relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IBinaryRelation.Left">
            <summary>
            Get the lefthand side term of this relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IBinaryRelation.Right">
            <summary>
            Get the righthand side term of this relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.ElementOf.#ctor(System.String,Impulse.v_1_336.ITerm,Impulse.v_1_336.ITerm)">
            <summary>
            Create a new element-of relation
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="left">The lefthand side of this relation</param>
            <param name="right">The righthand side of this relation</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.ElementOf.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.ElementOf.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.ElementOf.Left">
            <summary>
            Get the lefthand side term of this relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.ElementOf.Right">
            <summary>
            Get the righthand side term of this relation
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.TemporalBinaryRelation">
            <summary>
            A logical temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.TemporalBinaryRelation.#ctor(System.String,Impulse.v_1_336.ITerm,Impulse.v_1_336.ITerm,Impulse.v_1_336.Xml.RelationType)">
            <summary>
            Create a new temporal binary relation sentence
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="left">The lefthand side of this relation</param>
            <param name="right">The righthand side of this relation</param>
            <param name="type">The temporal relation type</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.TemporalBinaryRelation.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.TemporalBinaryRelation.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.TemporalBinaryRelation.Left">
            <summary>
            Get the lefthand side term of this relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.TemporalBinaryRelation.Right">
            <summary>
            Get the righthand side term of this relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.TemporalBinaryRelation.Type">
            <summary>
            Get the temporal relation type of this relation
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.IUnaryRelation">
            <summary>
            Interface representing unary relations
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IUnaryRelation.Type">
            <summary>
            The type of this unary relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IUnaryRelation.Sentence">
            <summary>
            The sentence of this unary relation
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.UnaryRelationType">
            <summary>
            Types of unary relations
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.UnaryRelationType.Not">
            <summary>
            Never true
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.UnaryRelationType.WeakNot">
            <summary>
            Not always true
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.UnaryRelation">
            <summary>
            A standard implementation of a unary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.UnaryRelation.#ctor(System.String,Impulse.v_1_336.ISentence,Impulse.v_1_336.Sentences.UnaryRelationType)">
            <summary>
            Create a new unary relation
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="sentence">The sentence of this unary relation</param>
            <param name="type">THe type of this unary relation</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.UnaryRelation.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.UnaryRelation.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.UnaryRelation.Sentence">
            <summary>
            The sentence of this unary relation
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.UnaryRelation.Type">
            <summary>
            The type of this unary relation
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.IConnective">
            <summary>
            Interface representing a logical connective
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IConnective.Left">
            <summary>
            Get the lefthand side of this connective
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IConnective.Right">
            <summary>
            Get the righthand side of this connective
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IConnective.Type">
            <summary>
            Get the type of this connective
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.ConnectiveType">
            <summary>
            Types of logical connective
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ConnectiveType.And">
            <summary>
            True if both sides are true
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ConnectiveType.Or">
            <summary>
            True if at least one side is true
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Sentences.ConnectiveType.Implies">
            <summary>
            Lefthand side implies righthand side
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.Connective">
            <summary>
            Standard implementation of a binary connective
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Connective.#ctor(System.String,Impulse.v_1_336.ISentence,Impulse.v_1_336.ISentence,Impulse.v_1_336.Sentences.ConnectiveType)">
            <summary>
            Create a new logical connective
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="left">The lefthand side of this connective</param>
            <param name="right">The righthand side of this connective</param>
            <param name="type">The type of this connective</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Connective.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Connective.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Connective.Left">
            <summary>
            Get the lefthand side of this connective
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Connective.Right">
            <summary>
            Get the righthand side of this connective
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Connective.Type">
            <summary>
            Get the type of this connective
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.IPredicate">
            <summary>
            Interface representing a predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IPredicate.Name">
            <summary>
            Get the name of this predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IPredicate.Terms">
            <summary>
            Get the terms of this predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IPredicate.Temporal">
            <summary>
            Get whether this is a temporal predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.IPredicate.Time">
            <summary>
            Get the time of this predicate, if any
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Sentences.Predicate">
            <summary>
            Standard implementation of a predicate
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.#ctor(System.String,System.String,System.Boolean,Impulse.v_1_336.ITerm[])">
            <summary>
            Create a new predicate
            </summary>
            <param name="id">The ID of this sentence</param>
            <param name="name">The name of this predicate</param>
            <param name="temporal">Whether this is a temporal predicate</param>
            <param name="terms">The terms of this predicate</param>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check if this predicate is equal to another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if term is a predicate with same name and terms</returns>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.Equals(Impulse.v_1_336.Sentences.IPredicate)">
            <summary>
            Check if this predicate is equal to another
            </summary>
            <param name="pred">The pred to compare to</param>
            <returns><see langword="true"/> if if both predicates have the same name and terms</returns>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.Equals(System.Object)">
            <summary>
            Check if this predicate is equal to another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if obj is a predicate with same name and terms</returns>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.GetHashCode">
            <summary>
            Computes a hash code based on this predicates string representation
            </summary>
            <returns>A hash code based on this predicates string representation</returns>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.ToString">
            <summary>
            Turns this predicate into a string representation
            </summary>
            <returns>A string representation of this predicate</returns>
        </member>
        <member name="M:Impulse.v_1_336.Sentences.Predicate.ToXmlSentence">
            <summary>
            Turn this sentence into an XML serializable version
            </summary>
            <returns>An XML sentence</returns>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Predicate.ID">
            <summary>
            Get the ID of this sentence
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Predicate.Name">
            <summary>
            Get the name of this predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Predicate.Temporal">
            <summary>
            Get whether this is a temporal predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Predicate.Terms">
            <summary>
            Get the terms of this predicate
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Sentences.Predicate.Time">
            <summary>
            Get the time of this predicate, if any
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.StoryParsingFactories">
            <summary>
            Collection of standard story parsing factories and related utility functions
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactories.GetUnsignedIntergerIntervalFactory">
            <summary>
            Create an unsigned integer interval factory
            </summary>
            <returns>An unsigned integer interval factory</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactories.ParseStory(Impulse.v_1_336.StoryParsingFactory{Impulse.v_1_336.Constants.ValueConstant{System.UInt32},Impulse.v_1_336.Interval{Impulse.v_1_336.Constants.ValueConstant{System.UInt32},System.UInt32}},Impulse.v_1_336.Xml.Story,System.Boolean)">
            <summary>
            Parse a story using an unsigned integer interval factory
            </summary>
            <param name="factory">The factory to use</param>
            <param name="storyXml">The story XML to parse</param>
            <param name="validate">Whether to validate the incoming XML</param>
            <returns>A story object containing the parsed result</returns>
        </member>
        <member name="T:Impulse.v_1_336.StoryParsingFactory`2">
            <summary>
            A class for parsing XML stories into a more structured object
            </summary>
            <typeparam name="TTime">The type to use as Time, must inherit <see cref="T:Impulse.v_1_336.IConstant"/></typeparam>
            <typeparam name="TInterval">The type to use as intervals, must inherit <see cref="T:Impulse.v_1_336.IInterval`1"/></typeparam>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactory`2.#ctor(Impulse.v_1_336.IConstantParser{`1})">
            <summary>
            Create a new story parsing factory with the specified interval parser
            </summary>
            <param name="intervalParser">The parser for intervals</param>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactory`2.RegisterObjectSet(System.String,Impulse.v_1_336.IObjectSet,System.Boolean)">
            <summary>
            Register a custom object set for use in parsing
            </summary>
            <param name="setName">The alias of the object set</param>
            <param name="set">The object set</param>
            <param name="replace"><see langword="true"/> to replace an existing object set</param>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactory`2.RegisterStoryAction(System.String,Impulse.v_1_336.CreateStoryAction{`1},System.Boolean)">
            <summary>
            Register a custom constructor for a given story action type
            </summary>
            <param name="actionType">The name of the story action type</param>
            <param name="createStoryAction">The constructor</param>
            <param name="replace"><see langword="true"/> to replace an existing constructor</param>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactory`2.RegisterConstantParser(System.String,Impulse.v_1_336.IConstantParser,System.Boolean)">
            <summary>
            Register a custom constant parser for an object set
            </summary>
            <param name="objectSet">The object set name to parse</param>
            <param name="parser">The parser</param>
            <param name="replace"><see langword="true"/> to replace an existing constant parser</param>
        </member>
        <member name="M:Impulse.v_1_336.StoryParsingFactory`2.ParseStory``1(Impulse.v_1_336.Xml.Story,``0,System.Boolean)">
            <summary>
            Parse an XML story
            </summary>
            <typeparam name="TIntervalSet">The type of the set of intervals</typeparam>
            <param name="storyXml">The story XML</param>
            <param name="intervals">The set of intervals</param>
            <param name="validate">Whether to validate the XML</param>
            <returns>A story object</returns>
        </member>
        <member name="T:Impulse.v_1_336.ObjectSet`1">
            <summary>
            Standard implementation of an object set where membership is determined by type alone
            </summary>
            <typeparam name="TConstant">The type the set contains</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSet`1.#ctor(System.String)">
            <summary>
            Create a new set with the given name
            </summary>
            <param name="name">The name of the set</param>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSet`1.Contains(`0)">
            <summary>
            Always returns true
            </summary>
            <param name="constant">The constant to check membership on</param>
            <returns><see langword="true"/></returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSet`1.Contains(Impulse.v_1_336.IConstant)">
            <summary>
            Checks if a given constant is in the set
            </summary>
            <param name="constant">The constant to check</param>
            <returns><see langword="true"/> if the constant is <c>TConstant</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSet`1.IsSubsetOf(Impulse.v_1_336.IObjectSet)">
            <summary>
            Checks if this set is a subset of another set
            </summary>
            <param name="other">The other set</param>
            <returns><see langword="true"/> if and only if the type of other is this type</returns>
        </member>
        <member name="P:Impulse.v_1_336.ObjectSet`1.Name">
            <summary>
            The name of this set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ObjectSetExtensions">
            <summary>
            Extension methods for object sets
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSetExtensions.IsSupersetOf(Impulse.v_1_336.IObjectSet,Impulse.v_1_336.IObjectSet)">
            <summary>
            Check if one object set is a superset of another
            </summary>
            <param name="set">The left-hand side</param>
            <param name="other">The right-hand side</param>
            <returns><c>other.IsSubsetOf(set)</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSetExtensions.IsSupersetOf``1(Impulse.v_1_336.IObjectSet{``0},Impulse.v_1_336.IFiniteObjectSet{``0})">
            <summary>
            Checks if a set is a superset of a finite set
            </summary>
            <typeparam name="TConstant">The type of constants in both sets</typeparam>
            <param name="subset">The finite set</param>
            <param name="set">The other set</param>
            <returns><see langrod="true"/> if all the constants in the subset are also elements of set</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSetExtensions.IsSubsetOf``1(Impulse.v_1_336.IFiniteObjectSet{``0},Impulse.v_1_336.IObjectSet{``0})">
            <summary>
            Checks if a finite set is a subset of another set
            </summary>
            <typeparam name="TConstant">The type of constants in both sets</typeparam>
            <param name="subset">The finite set</param>
            <param name="set">The other set</param>
            <returns><see langrod="true"/> if all the constants in the subset are also elements of set</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSetExtensions.Equals``1(Impulse.v_1_336.IFiniteObjectSet{``0},Impulse.v_1_336.IFiniteObjectSet{``0})">
            <summary>
            Check if two finite sets are equal
            </summary>
            <typeparam name="TConstant">The type of constants in sets</typeparam>
            <param name="setA">The first set</param>
            <param name="setB">The second set</param>
            <returns><see langword="true"/> if both sets contain precisely the same elements</returns>
        </member>
        <member name="M:Impulse.v_1_336.ObjectSetExtensions.Equals(Impulse.v_1_336.IObjectSet,Impulse.v_1_336.IObjectSet)">
            <summary>
            Check if two sets are equal
            </summary>
            <param name="setA">The first set</param>
            <param name="setB">The second set</param>
            <returns><see langword="true"/> if both sets are subsets of each other</returns>
        </member>
        <member name="T:Impulse.v_1_336.TermExtensions">
            <summary>
            Extension methods for terms
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.ToXmlVariable(Impulse.v_1_336.Variable)">
            <summary>
            Turn a variable into its XML object equivalent
            </summary>
            <param name="variable">The variable to convert</param>
            <returns>An XML representation of the variable</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.ToXmlFunction(Impulse.v_1_336.IFunction)">
            <summary>
            Turn a function into its XML object equivalent
            </summary>
            <param name="function">The function to convert</param>
            <returns>An XML representation of the function</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.ToXmlConstant(Impulse.v_1_336.IConstant)">
            <summary>
            Turn a constant into its XML object equivalent
            </summary>
            <param name="constant">The constant to convert</param>
            <returns>An XML representation of the constant</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.ToXmlTerm(Impulse.v_1_336.ITerm)">
            <summary>
            Turn a term into its XML object equivalent
            </summary>
            <param name="term">The term to convert</param>
            <returns>An XML representation of the term</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsFunction(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as a function if possible.
            </summary>
            <param name="term">The term to convert</param>
            <returns>A function or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsVariable(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as a variable if possible.
            </summary>
            <param name="term">The term to convert</param>
            <returns>A variable or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsConstant(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as a constant if possible.
            </summary>
            <param name="term">The term to convert</param>
            <returns>A constant or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsConstant``1(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as a constant if possible.
            </summary>
            <typeparam name="T">The type the constant contains</typeparam>
            <param name="term">The term to convert</param>
            <returns>A constant or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsInterval(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as an interval if possible.
            </summary>
            <param name="term">The term to convert</param>
            <returns>An interval or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsInterval``1(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as an interval if possible.
            </summary>
            <typeparam name="TTime">The type of endpoints</typeparam>
            <param name="term">The term to convert</param>
            <returns>An interval or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.TermExtensions.AsInterval``2(Impulse.v_1_336.ITerm)">
            <summary>
            Treat this term as an interval if possible.
            </summary>
            <typeparam name="TTime">The type of times</typeparam>
            <typeparam name="T">The type times wrap</typeparam>
            <param name="term">The term to convert</param>
            <returns>An interval or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="T:Impulse.v_1_336.TryParse`1">
            <summary>
            Delegate type describing the standard C# TryParse pattern
            </summary>
            <typeparam name="T">The type to parse</typeparam>
            <param name="input">The input string</param>
            <param name="value">The resulting object</param>
            <returns><see langword="true"/> is parsing was successful</returns>
        </member>
        <member name="T:Impulse.v_1_336.TypeExtensions">
            <summary>
            Extension methods for <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.GetCSharpName(System.Type)">
            <summary>
            Get the name of the type in C# syntax
            </summary>
            <param name="type">The type to get the name of</param>
            <returns>The C# syntax name of the type</returns>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.TryGetMethod``1(System.Type,System.String,``0@)">
            <summary>
            Try to get a method of a type
            </summary>
            <typeparam name="TDelegate">The delegate type to match</typeparam>
            <param name="ttype">The type to search</param>
            <param name="name">The name of the method</param>
            <param name="delegate">The resulting delegate, <see langword="null"/> if not found</param>
            <returns><see langword="true"/> if the method was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.TryGetMethod``2(System.String,``1@)">
            <summary>
            Try to get a method of a type
            </summary>
            <typeparam name="TType">The type to search</typeparam>
            <typeparam name="TDelegate">The delegate type to match</typeparam>
            <param name="name">The name of the method</param>
            <param name="delegate">The resulting delegate, <see langword="null"/> if not found</param>
            <returns><see langword="true"/> if the method was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.GetMethod``2(System.String)">
            <summary>
            Try to get a method of a type
            </summary>
            <typeparam name="TDelegate">The delegate type to match</typeparam>
            <typeparam name="TType">The type to search</typeparam>
            <param name="name">The name of the method</param>
            <returns>The resulting delegate</returns>
            <exception cref="T:System.NotImplementedException">If the specified function is not found</exception>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.GetMethod``1(System.Type,System.String)">
            <summary>
            Try to get a method of a type
            </summary>
            <param name="type">The type to search</param>
            <typeparam name="TDelegate">The delegate type to match</typeparam>
            <param name="name">The name of the method</param>
            <returns>The resulting delegate</returns>
            <exception cref="T:System.NotImplementedException">If the specified function is not found</exception>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.TryGetParser``1(Impulse.v_1_336.TryParse{``0}@)">
            <summary>
            Tries to get a TryParse function for the given type
            </summary>
            <typeparam name="T">The type to search</typeparam>
            <param name="parser">The resulting delegate if found, else <see langword="null"/></param>
            <returns><see langword="true"/> if a TryParse method was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.TryParse``1(System.String,``0@)">
            <summary>
            Try parse a string into an object
            </summary>
            <typeparam name="T">The type to create</typeparam>
            <param name="input">The string representation of the type</param>
            <param name="value">The resulting object</param>
            <returns><see langword="true"/> if a parsing was successful</returns>
        </member>
        <member name="M:Impulse.v_1_336.TypeExtensions.GetInterfaceFromGeneric(System.Type,System.Type,System.Type@)">
            <summary>
            Get the closed type definition from an open type definition and a type
            </summary>
            <param name="type">The type to check</param>
            <param name="genericTypeDefinition">The open type</param>
            <param name="closedTypeDefinition">The resulting closed type</param>
            <returns><see langword="true"/> if the type implements the open type</returns>
        </member>
        <member name="T:Impulse.v_1_336.Variable">
            <summary>
            Represents a variable in a logical sentence
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Variable.#ctor(System.String,Impulse.v_1_336.IObjectSet)">
            <summary>
            Create a new variable with the specified name and range
            </summary>
            <param name="name">The name of this variable</param>
            <param name="set">The range of this variable</param>
        </member>
        <member name="M:Impulse.v_1_336.Variable.Equals(System.Object)">
            <summary>
            Check is this variable is equal to another object
            </summary>
            <param name="obj">the object to compare to</param>
            <returns><see langword="true"/> if <c>obj</c> is a variable with <c>obj.name</c> equal to <c>this.name</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.Variable.GetHashCode">
            <summary>
            Gets the hash code for the variable
            </summary>
            <returns>The hash of the name of the variable</returns>
        </member>
        <member name="M:Impulse.v_1_336.Variable.Equals(Impulse.v_1_336.Variable)">
            <summary>
            Check is this variable is equal to another variable
            </summary>
            <param name="other">The variable to compare to</param>
            <returns><see langword="true"/> if <c>other.name</c> equals <c>this.name</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.Variable.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Check is this variable is equal to another term
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if <c>term</c> is a variable with <c>term.name</c> equal to <c>this.name</c></returns>
        </member>
        <member name="M:Impulse.v_1_336.Variable.ToString">
            <summary>
            The name of the variable
            </summary>
            <returns>The name of the variable</returns>
        </member>
        <member name="P:Impulse.v_1_336.Variable.Name">
            <summary>
            The name of the variable
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Variable.Set">
            <summary>
            The set the variable belongs to
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IFunction">
            <summary>
            Interface for a function
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IFunction.Terms">
            <summary>
            Gets the ordered terms of this function
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IFunction.Temporal">
            <summary>
            Gets whether this function is temporal
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IFunction.Time">
            <summary>
            Gets the interval of this function, if any
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Function">
            <summary>
            A standard implementation of a function
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Function.#ctor(System.String,System.Boolean,Impulse.v_1_336.ITerm[])">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="temporal"></param>
            <param name="terms"></param>
        </member>
        <member name="M:Impulse.v_1_336.Function.Equals(Impulse.v_1_336.IFunction)">
            <summary>
            Determines whether this function is equal to another
            </summary>
            <param name="other">The function to compare to</param>
            <returns><see langword="true"/> if both functions names and terms are equal</returns>
        </member>
        <member name="M:Impulse.v_1_336.Function.Equals(Impulse.v_1_336.ITerm)">
            <summary>
            Determines whether this function is equal to another
            </summary>
            <param name="term">The term to compare to</param>
            <returns><see langword="true"/> if both functions names and terms are equal</returns>
        </member>
        <member name="M:Impulse.v_1_336.Function.Equals(System.Object)">
            <summary>
            Determines whether this function is equal to another
            </summary>
            <param name="obj">The object to compare to</param>
            <returns><see langword="true"/> if both functions names and terms are equal</returns>
        </member>
        <member name="M:Impulse.v_1_336.Function.GetHashCode">
            <summary>
            Gets the hash code of this function
            </summary>
            <returns>The hash code of this.ToString()</returns>
        </member>
        <member name="M:Impulse.v_1_336.Function.ToString">
            <summary>
            Turn this function into a string representation
            </summary>
            <returns>A string representation of this function</returns>
        </member>
        <member name="P:Impulse.v_1_336.Function.Name">
            <summary>
            The name of this function
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Function.Terms">
            <summary>
            Gets the ordered terms of this function
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Function.Temporal">
            <summary>
            Gets whether this function is termporal (its last argument is an interval)
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Function.Time">
            <summary>
            Gets the last argument of this function as an interval
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsBinaryRelation(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a binary relation if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A binary relation or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsElementOf(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as an element-of relation if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>An element-of relation or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsTemporalBinaryRelation(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a temporal binary relation if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A temporal binary relation or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsConnective(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a connective if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A connective or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsModality(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a modality if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A modality or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsPredicate(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a predicate if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A predicate or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsQuantifer(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a quantifier if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A quantifier or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="M:Impulse.v_1_336.SentenceExtensions.AsUnaryRelation(Impulse.v_1_336.ISentence)">
            <summary>
            Treat this sentence as a unary relation if possible.
            </summary>
            <param name="sentence">The sentence to convert</param>
            <returns>A unary relation or <see langword="null"/> if conversion fails</returns>
        </member>
        <member name="T:Impulse.v_1_336.ActionPropertyDefinition">
            <summary>
            Class representing a story action property definition
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.ActionPropertyDefinition.#ctor(System.String,Impulse.v_1_336.IObjectSet)">
            <summary>
            Create a new story action property definition
            </summary>
            <param name="name">The name of the property</param>
            <param name="range">The object set range of the property</param>
        </member>
        <member name="P:Impulse.v_1_336.ActionPropertyDefinition.Name">
            <summary>
            Get the name of the property
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.ActionPropertyDefinition.Range">
            <summary>
            Get the object set range of the property
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IActionProperty">
            <summary>
            Interface representing an action property
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IActionProperty.Name">
            <summary>
            Gets the name of this property
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IActionProperty.Value">
            <summary>
            Gets the value of this property
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IActionProperty.Range">
            <summary>
            Gets the range of the value of this property
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IActionProperty`1">
            <summary>
            Interface representing an action property with specific constant type
            </summary>
            <typeparam name="TConstant">The type of constant</typeparam>
        </member>
        <member name="P:Impulse.v_1_336.IActionProperty`1.Value">
            <summary>
            Gets the value of this property
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.ActionProperty`1">
            <summary>
            Standard implementation of an action property
            </summary>
            <typeparam name="TConstant"></typeparam>
        </member>
        <member name="M:Impulse.v_1_336.ActionProperty`1.#ctor(System.String,`0,Impulse.v_1_336.IObjectSet{`0},System.Boolean)">
            <summary>
            Create a new action property
            </summary>
            <param name="name">The name of the property</param>
            <param name="value">The value of the property</param>
            <param name="range">The range of the value of this property</param>
            <param name="verify"><see langword="true"/> to verify the value exists in the range</param>
        </member>
        <member name="P:Impulse.v_1_336.ActionProperty`1.Name">
            <summary>
            Gets the name of this property
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.ActionProperty`1.Value">
            <summary>
            Gets the value of this property
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.IStoryAction">
            <summary>
            Interface describing a general story action
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.IStoryAction.GetProperty(System.String)">
            <summary>
            Get a named property
            </summary>
            <param name="name">The name of the property</param>
            <returns>The given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="M:Impulse.v_1_336.IStoryAction.TryGetProperty(System.String,Impulse.v_1_336.IActionProperty@)">
            <summary>
            Try to get a named property
            </summary>
            <param name="name">The name of the property</param>
            <param name="property">The given property</param>
            <returns><see langword="true"/> if the given property was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.IStoryAction.ToXmlAction">
            <summary>
            Convert the story action into an XML representation
            </summary>
            <returns>An XML representation of the action</returns>
        </member>
        <member name="P:Impulse.v_1_336.IStoryAction.Name">
            <summary>
            Get the name of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStoryAction.Time">
            <summary>
            Get the interval of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStoryAction.ActionType">
            <summary>
            Get the story action type of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStoryAction.Properties">
            <summary>
            Get the properties of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.IStoryAction.Item(System.String)">
            <summary>
            Get a named property value
            </summary>
            <param name="name">The name of the property</param>
            <returns>The value of the given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="T:Impulse.v_1_336.IStoryAction`1">
            <summary>
            Interface describing a story action using a specific interval type
            </summary>
            <typeparam name="TInterval"></typeparam>
        </member>
        <member name="P:Impulse.v_1_336.IStoryAction`1.Time">
            <summary>
            Get the interval of the action
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.CreateStoryAction`1">
            <summary>
            General form of a story action constructor for parsing
            </summary>
            <typeparam name="TInterval">The type of interval</typeparam>
            <param name="name">The name</param>
            <param name="time">The interval</param>
            <param name="actionType">The story action type</param>
            <param name="actionProperties">The properties</param>
            <param name="validate">Whether to validate of the properties match the type</param>
            <returns>A new story action</returns>
        </member>
        <member name="T:Impulse.v_1_336.StoryAction`1">
            <summary>
            Concrete implementation of a story action
            </summary>
            <typeparam name="TInterval">The interval type</typeparam>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.GetProperty(System.String)">
            <summary>
            Get a named property
            </summary>
            <param name="name">The name of the property</param>
            <returns>The given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.TryGetProperty(System.String,Impulse.v_1_336.IActionProperty@)">
            <summary>
            Try to get a named property
            </summary>
            <param name="name">The name of the property</param>
            <param name="property">The given property</param>
            <returns><see langword="true"/> if the given property was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.TryGetProperty``1(System.String,Impulse.v_1_336.IActionProperty{``0}@)">
            <summary>
            Try to get a named property
            </summary>
            <typeparam name="TConstant">The type of constant the property should encapsulate</typeparam>
            <param name="name">The name of the property</param>
            <param name="property">The given property</param>
            <returns><see langword="true"/> if the given property was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.#ctor(System.String,`0,Impulse.v_1_336.ActionType,System.Collections.Generic.IEnumerable{Impulse.v_1_336.IActionProperty},System.Boolean)">
            <summary>
            Create a story action
            </summary>
            <param name="name">The name</param>
            <param name="time">The interval</param>
            <param name="actionType">The story action type</param>
            <param name="actionProperties">The properties</param>
            <param name="validate">Whether to validate of the properties match the type</param>
            <returns>A new story action</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.ToXmlAction">
            <summary>
            Convert the story action into an XML representation
            </summary>
            <returns>An XML representation of the action</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.Equals(Impulse.v_1_336.StoryAction{`0})">
            <summary>
            Check if two story actions are equal
            </summary>
            <param name="other">The story action to compare to</param>
            <returns><see langword="true"/> if both actions have the same name</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.Equals(Impulse.v_1_336.IStoryAction)">
            <summary>
            Check if two story actions are equal
            </summary>
            <param name="other">The story action to compare to</param>
            <returns><see langword="true"/> if <paramref name="other"/> is not <see langword="null"/> and both actions have the same name</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.Equals(System.Object)">
            <summary>
            Check if two story actions are equal
            </summary>
            <param name="obj">The story action to compare to</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a story action and both actions have the same name</returns>
        </member>
        <member name="M:Impulse.v_1_336.StoryAction`1.GetHashCode">
            <summary>
            Compute the hash code of this action
            </summary>
            <returns>The hash code of <see cref="F:StoryAction{TInterval}.Name"/></returns>
        </member>
        <member name="P:Impulse.v_1_336.StoryAction`1.Name">
            <summary>
            Get the name of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.StoryAction`1.Time">
            <summary>
            Get the interval of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.StoryAction`1.ActionType">
            <summary>
            Get the story action type
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.StoryAction`1.Properties">
            <summary>
            Get the properties of the action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.StoryAction`1.Item(System.String)">
            <summary>
            Get a named property value
            </summary>
            <param name="name">The name of the property</param>
            <returns>The value of the given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="T:Impulse.v_1_336.AStoryAction`1">
            <summary>
            Abstract implementation of a story action
            </summary>
            <typeparam name="TInterval"></typeparam>
        </member>
        <member name="F:Impulse.v_1_336.AStoryAction`1.name">
            <summary>
            The name of this action
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.AStoryAction`1.time">
            <summary>
            The interval of this action
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.AStoryAction`1.actionType">
            <summary>
            The action type of this action
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.AStoryAction`1.actionProperties">
            <summary>
            The properties of this action
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.AStoryAction`1.GetProperty(System.String)">
            <summary>
            Get a named property
            </summary>
            <param name="name">The name of the property</param>
            <returns>The given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="M:Impulse.v_1_336.AStoryAction`1.TryGetProperty(System.String,Impulse.v_1_336.IActionProperty@)">
            <summary>
            Try to get a named property
            </summary>
            <param name="name">The name of the property</param>
            <param name="property">The given property</param>
            <returns><see langword="true"/> if the given property was found</returns>
        </member>
        <member name="M:Impulse.v_1_336.AStoryAction`1.#ctor(System.String,`0,Impulse.v_1_336.ActionType,System.Collections.Generic.IEnumerable{Impulse.v_1_336.IActionProperty},System.Boolean)">
            <summary>
            Create a story action
            </summary>
            <param name="name">The name</param>
            <param name="time">The interval</param>
            <param name="actionType">The story action type</param>
            <param name="actionProperties">The properties</param>
            <param name="validate">Whether to validate of the properties match the type</param>
            <returns>A new story action</returns>
        </member>
        <member name="M:Impulse.v_1_336.AStoryAction`1.ToXmlAction">
            <summary>
            Convert the story action into an XML representation
            </summary>
            <returns>An XML representation of the action</returns>
        </member>
        <member name="P:Impulse.v_1_336.AStoryAction`1.Name">
            <summary>
            Get the name of this action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStoryAction`1.Time">
            <summary>
            Get the interval of this action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStoryAction`1.ActionType">
            <summary>
            Get the story action type
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStoryAction`1.Properties">
            <summary>
            Get the properties of this action
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.AStoryAction`1.Item(System.String)">
            <summary>
            Get a named property value
            </summary>
            <param name="name">The name of the property</param>
            <returns>The value of the given property</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If the action does not contain the named property</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.MathName">
            <summary>
            Static class for validating math names
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.MathName.Regex">
            <summary>
            The regular expression for math names
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.MathName.Validate(System.String,System.Boolean)">
            <summary>
            Validate a math name
            </summary>
            <param name="value">The value to validate as a math name</param>
            <param name="allowNull">Whether <see langword="null"/> is an acceptable argument</param>
            <exception cref="T:System.ArgumentNullException">If the value is <see langword="null"/> and <paramref name="allowNull"/> is <see langword="false"/></exception>
            <exception cref="T:System.ArgumentNullException">If the value does not match the regular expression</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Operation">
            <summary>
            Types of set operations
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Operation.Union">
            <summary>
            Union all referenced sets, explicit sets, and explicit parameters as the members of a set
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Operation.Intersection">
            <summary>
            Intersect all referenced sets, explicit sets, and explicit parameters as the members of this set
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Xml.SetRef">
            <summary>
            Struct representing a reference to a set by name
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ISupportsSerialization">
            <summary>
            Interface denoting a class that should have serialization extensions
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.SetRef.#ctor(System.String)">
            <summary>
            Create a new set reference
            </summary>
            <param name="name">The name of the set to reference, must be a valid math name and not <see langword="null"/></param>
        </member>
        <member name="M:Impulse.v_1_336.Xml.SetRef.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.SetRef.Name">
            <summary>
            Get or set the name of the referenced set
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ObjectSet">
            <summary>
            Class representing an object set
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ObjectSet.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ObjectSet.#ctor(System.String,Impulse.v_1_336.Xml.Operation,Impulse.v_1_336.Xml.ObjectSet[],Impulse.v_1_336.Xml.SetRef[],Impulse.v_1_336.Xml.Constant[])">
            <summary>
            Create a new object set
            </summary>
            <param name="name">The name of this object set, must be a valid math name</param>
            <param name="operation">The operation to perform on this sets parameters</param>
            <param name="explicitSets">The explicit subsets of this set</param>
            <param name="referencedSets">The referenced subsets of this set</param>
            <param name="constants">The constants that are explicit constants of this set</param>
            <remarks>
            Passing <see langword="null"/> for <paramref name="explicitSets"/>, <paramref name="referencedSets"/>,
            or <paramref name="constants"/> results in that value being set to an empty array
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ObjectSet.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSet.Name">
            <summary>
            Get or set the name of this object set
            </summary>
            <remarks>Must be a valid math name</remarks>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSet.Operation">
            <summary>
            Get or set the operation of this set
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSet.ExplicitSets">
            <summary>
            Get or set the explicit sets of this set
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in the value being set to an empty array</remarks>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSet.ReferencedSets">
            <summary>
            Get or set the referenced sets of this set
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in the value being set to an empty array</remarks>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSet.Constants">
            <summary>
            Get or set the explicit constants of this set 
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in the value being set to an empty array</remarks>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ObjectSetRoot">
            <summary>
            Class representing the set of all objects
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ObjectSetRoot.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ObjectSetRoot.#ctor(Impulse.v_1_336.Xml.ObjectSet[],Impulse.v_1_336.Xml.SetRef[],Impulse.v_1_336.Xml.Constant[])">
            <summary>
            Create a new object set root
            </summary>
            <param name="explicitSubsets">The explicit subsets of this set</param>
            <param name="referencedSubsets">The referenced subsets of this set</param>
            <param name="constants">The constants that are explicit constants of this set</param>
            <remarks>
            Passing <see langword="null"/> for <paramref name="explicitSubsets"/>, <paramref name="referencedSubsets"/>,
            or <paramref name="constants"/> results in that value being set to an empty array
            </remarks>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ObjectSetRoot.ComputeObjectSets(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{System.String}}@,System.Collections.Generic.HashSet{System.String}@)">
            <summary>
            Compute the members of all object sets under this root
            </summary>
            <param name="sets">A dictionary of object set names to hash sets of members</param>
            <param name="allConstants">A hash set containing every constant</param>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSetRoot.Name">
            <summary>
            Get <see cref="F:Impulse.v_1_336.Xml.Story.ObjectsSetName"/>
            </summary>
            <remarks>This property cannot be changed</remarks>
            <exception cref="T:System.InvalidOperationException">When trying to change this property</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ObjectSetRoot.Operation">
            <summary>
            Get <see cref="F:Operation.Union"/>
            </summary>
            <remarks>This property cannot be changed</remarks>
            <exception cref="T:System.InvalidOperationException">When trying to change this property</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Action">
            <summary>
            Struct representing a story action
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Action.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{Impulse.v_1_336.Xml.ActionProperty})">
            <summary>
            Create a new story action
            </summary>
            <param name="name">The name of this action</param>
            <param name="type">The action type of this action</param>
            <param name="properties">The list of properties of this action</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> or <paramref name="type"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> or <paramref name="type"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Action.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Action.Type">
            <summary>
            Get or set the action type
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Action.Name">
            <summary>
            Get or set the name of this action
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Action.Properties">
            <summary>
            Get or set the properties of this action
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in the value being set to an empty array</remarks>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ActionProperty">
            <summary>
            Struct representing a property of an action
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionProperty.#ctor(System.String,System.String)">
            <summary>
            Create a new action property
            </summary>
            <param name="name">The name of this property, must be a valid math name and not <see langword="null"/></param>
            <param name="value">The value of this property, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> or <paramref name="value"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionProperty.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionProperty.Name">
            <summary>
            Get or set the name of this action property
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionProperty.Value">
            <summary>
            Get or set the name of this action property
            </summary>
            <remarks>Must not be <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ActionPropertyDefinition">
            <summary>
            Struct representing an action property definition
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionPropertyDefinition.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a new action property definition
            </summary>
            <param name="name">The name of this property, must be a valid math name and not <see langword="null"/></param>
            <param name="action">The action type that has this property, must be a valid math name and not <see langword="null"/></param>
            <param name="range">The name of the object set which is the range of this property, must be a valid math name and not <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/>, <paramref name="action"/>, or <paramref name="range"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/>, <paramref name="action"/>, or <paramref name="range"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionPropertyDefinition.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionPropertyDefinition.Name">
            <summary>
            Get or set the name of this property
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionPropertyDefinition.Action">
            <summary>
            Get or set the action type that has this property
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionPropertyDefinition.Range">
            <summary>
            Get or set the name of the object set which is the range of this property
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ActionSet">
            <summary>
            Class representing an action type set
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSet.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSet.#ctor(Impulse.v_1_336.Xml.Operation,Impulse.v_1_336.Xml.ActionSet[],Impulse.v_1_336.Xml.SetRef[])">
            <summary>
            Create a new action type
            </summary>
            <param name="operation">The operation to perform on this sets parameters</param>
            <param name="explicitSets">The explicit subtypes of this set</param>
            <param name="referencedSets">The referenced subtypes of this set</param>
            <remarks>
            Passing <see langword="null"/> for <paramref name="explicitSets"/> or <paramref name="referencedSets"/>
            results in that value being set to an empty array
            </remarks>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSet.#ctor(System.String,Impulse.v_1_336.Xml.Operation,Impulse.v_1_336.Xml.ActionSet[],Impulse.v_1_336.Xml.SetRef[])">
            <summary>
            Create a new action type
            </summary>
            <param name="name">The name of this action type, must be a valid math name</param>
            <param name="operation">The operation to perform on this sets parameters</param>
            <param name="explicitSets">The explicit subtypes of this set</param>
            <param name="referencedSets">The referenced subtypes of this set</param>
            <remarks>
            Passing <see langword="null"/> for <paramref name="explicitSets"/> or <paramref name="referencedSets"/>
            results in that value being set to an empty array
            </remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSet.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionSet.Name">
            <summary>
            Get or set the name of this object set
            </summary>
            <remarks>Must be a valid math name</remarks>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionSet.Operation">
            <summary>
            Get or set the operation of this set
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionSet.ExplicitSets">
            <summary>
            Get or set the explicit sets of this set
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in the value being set to an empty array</remarks>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionSet.ReferencedSets">
            <summary>
            Get or set the referenced sets of this set
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in the value being set to an empty array</remarks>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ActionSetRoot">
            <summary>
            Class representing the set of all actions
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSetRoot.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSetRoot.#ctor(Impulse.v_1_336.Xml.ActionSet[],Impulse.v_1_336.Xml.SetRef[])">
            <summary>
            Create a new action type root
            </summary>
            <param name="explicitSubsets">The explicit subtypes of this set</param>
            <param name="referencedSubsets">The referenced subtypes of this set</param>
            <remarks>
            Passing <see langword="null"/> for <paramref name="explicitSubsets"/> or <paramref name="referencedSubsets"/>
            results in that value being set to an empty array
            </remarks>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ActionSetRoot.ComputeActionTypeDependencies(LN.Utilities.Collections.DirectedGraph{System.String,LN.Utilities.Collections.Edge{System.String}}@,System.Collections.Generic.Dictionary{System.String,Impulse.v_1_336.Xml.ActionSet}@)">
            <summary>
            Compute the action type dependency graph and dictionary of types
            </summary>
            <param name="dependencyGraph">A directed graph of action type names with edges 'A1->A2' indicating 'A2 is a A1' relationships</param>
            <param name="actionSets">A dictionary of action type name to action set</param>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionSetRoot.Name">
            <summary>
            Get <see cref="F:Impulse.v_1_336.Xml.Story.ActionsSetName"/>
            </summary>
            <remarks>This property cannot be changed</remarks>
            <exception cref="T:System.InvalidOperationException">When trying to change this property</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.ActionSetRoot.Operation">
            <summary>
            Get <see cref="F:Operation.Union"/>
            </summary>
            <remarks>This property cannot be changed</remarks>
            <exception cref="T:System.InvalidOperationException">When trying to change this property</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Term">
            <summary>
            Class representing an abstract term
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Term.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Variable">
            <summary>
            Class representing a variable term
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Variable.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Variable.#ctor(System.String)">
            <summary>
            Create a new variable with the given name
            </summary>
            <param name="name">The name of this variable, must be a valid math name and not <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Variable.Name">
            <summary>
            Get or set the name of this variable
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Constant">
            <summary>
            Class representing a constant term
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Constant.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Constant.#ctor(System.String)">
            <summary>
            Create a new constant with the specified value
            </summary>
            <param name="value">The value of this variable, must be a valid math name and not <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="value"/> is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Constant.Value">
            <summary>
            Get or set the value of this constant
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Function">
            <summary>
            Class representing a function term
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Function.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Function.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term[])">
            <summary>
            Create a new function
            </summary>
            <param name="name">The name of this function, must be a valid math name and not <see langword="null"/></param>
            <param name="time">The time of this function, must not be <see langword="null"/></param>
            <param name="arguments">The terms of this function</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/>, <paramref name="time"/>, or <paramref name="arguments"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Function.#ctor(System.String,System.Boolean,Impulse.v_1_336.Xml.Term[])">
            <summary>
            Create a new function
            </summary>
            <param name="name">The name of this function, must be a valid math name and not <see langword="null"/></param>
            <param name="temporal">A value indicating if this function is temporal</param>
            <param name="arguments">The terms of this function</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> or <paramref name="arguments"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="name"/> is not a valid math name, or if <paramref name="temporal"/> 
            is <see langword="true"/> and the length of <paramref name="arguments"/> is 0
            </exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Function.Name">
            <summary>
            Get or set the name of this function
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Function.Temporal">
            <summary>
            Get or set whether this function is temporal
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Function.Arguments">
            <summary>
            Get or set the terms of this function
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in trying set it to an empty array</remarks>
            <exception cref="T:System.ArgumentException">If <see name="Function.Temporal"/> is <see langword="true"/> and the length of <paramref name="value"/> is 0</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Sentence">
            <summary>
            Class representing an abstract logical sentence
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Sentence.id">
            <summary>
            The ID of this sentence
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Sentence.#ctor">
            <summary>
            Create a new sentence with <see langword="null"/> ID
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Sentence.#ctor(System.String)">
            <summary>
            Create a new sentence with the given ID
            </summary>
            <param name="id">must be a valid math name or <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Sentence.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Sentence.ID">
            <summary>
            Get or set the ID of this sentence
            </summary>
            <remarks>Must be a valid math name and may be <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.SentenceReference">
            <summary>
            Class representing a reference to another sentence
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.SentenceReference.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.SentenceReference.#ctor(System.String)">
            <summary>
            Create a new sentence with the given ID
            </summary>
            <param name="id">must be a valid math name and not <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="id"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.SentenceReference.ID">
            <summary>
            Get or set the ID of this sentence reference
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Predicate">
            <summary>
            Sentence type representing a predicate
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Predicate.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Predicate.#ctor(System.String,System.Boolean,Impulse.v_1_336.Xml.Term[])">
            <summary>
            Create a new predicate
            </summary>
            <param name="name">The name of this predicate, must be a valid math name and not <see langword="null"/></param>
            <param name="temporal">A value indicating if this predicate is temporal</param>
            <param name="terms">The terms of this predicate</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> or <paramref name="terms"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="name"/> is not a valid math name, or if <paramref name="temporal"/> 
            is <see langword="true"/> and the length of <paramref name="terms"/> is 0
            </exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Predicate.#ctor(System.String,System.String,System.Boolean,Impulse.v_1_336.Xml.Term[])">
            <summary>
            Create a new predicate
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="name">The name of this predicate, must be a valid math name and not <see langword="null"/></param>
            <param name="temporal">A value indicating if this predicate is temporal</param>
            <param name="terms">The terms of this predicate</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="name"/> or <paramref name="terms"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">
            If <paramref name="name"/> or <paramref name="id"/> is not a valid math name, or if <paramref name="temporal"/> 
            is <see langword="true"/> and the length of <paramref name="terms"/> is 0
            </exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Predicate.Name">
            <summary>
            Get or set the name of this predicate
            </summary>
            <remarks>Must be a valid math name and not <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Predicate.Temporal">
            <summary>
            Get or set whether this predicate is temporal
            </summary>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Predicate.Terms">
            <summary>
            Get or set the terms of this predicate
            </summary>
            <remarks>Assigning <see langword="null"/> to this property results in trying set it to an empty array</remarks>
            <exception cref="T:System.ArgumentException">If <see name="Predicate.Temporal"/> is <see langword="true"/> and the length of <paramref name="value"/> is 0</exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Connective">
            <summary>
            Sentence type representing an abstract logical connective
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Connective.leftHandSide">
            <summary>
            The left-hand side operand (first)
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Connective.rightHandSide">
            <summary>
            The right-hand side operand (second)
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Connective.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Connective.#ctor(Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical connective
            </summary>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Connective.#ctor(System.String,Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical connective
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Connective.FirstOperand">
            <summary>
            Get or set the first operand (left-hand side) of this connective
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Connective.SecondOperand">
            <summary>
            Get or set the second operand (right-hand side) of this connective
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.And">
            <summary>
            Sentence type representing an AND logical connective
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.And.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.And.#ctor(Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical AND
            </summary>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.And.#ctor(System.String,Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical AND
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Or">
            <summary>
            Sentence type representing an OR logical connective
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Or.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Or.#ctor(Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical OR
            </summary>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Or.#ctor(System.String,Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical OR
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Implies">
            <summary>
            Sentence type representing an IMPLIES logical connective
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Implies.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Implies.#ctor(Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical implication
            </summary>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Implies.#ctor(System.String,Impulse.v_1_336.Xml.Sentence,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical implication
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first operand (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second operand (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> are <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Modality">
            <summary>
            Sentence type representing an abstract logical modality
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Modality.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Modality.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal modality
            </summary>
            <param name="actor">The actor of this modality, must not be <see langword="null"/></param>
            <param name="time">The temporal aspect of this modality, must not be <see langword="null"/></param>
            <param name="expression">The expression contained by this modality, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Modality.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal modality
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="actor">The actor of this modality, must not be <see langword="null"/></param>
            <param name="time">The temporal aspect of this modality, must not be <see langword="null"/></param>
            <param name="expression">The expression contained by this modality, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Modality.Actor">
            <summary>
            Get or set the actor of this modality
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Modality.Time">
            <summary>
            Get or set the temporal aspect of this modality
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Modality.Expression">
            <summary>
            Get or set the expression contained by this modality
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.B">
            <summary>
            Sentence type representing a belief temporal modality
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.B.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.B.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal belief
            </summary>
            <param name="actor">The actor of this belief, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this belief, must not be <see langword="null"/></param>
            <param name="expression">The expression believed by the actor, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.B.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal belief
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="actor">The actor holding this belief, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this belief, must not be <see langword="null"/></param>
            <param name="expression">The expression believed by this actor, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.D">
            <summary>
            Sentence type representing a desire temporal modality
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.D.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.D.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal desire
            </summary>
            <param name="actor">The actor having this desire, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this desire, must not be <see langword="null"/></param>
            <param name="expression">The expression desired by this actor, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.D.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal desire
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="actor">The actor having this desire, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this desire, must not be <see langword="null"/></param>
            <param name="expression">The expression desired by this actor, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.I">
            <summary>
            Sentence type representing an intention temporal modality
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.I.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.I.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal intention
            </summary>
            <param name="actor">The actor having this intention, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this intention, must not be <see langword="null"/></param>
            <param name="expression">The expression intended by this actor, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.I.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal intention
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="actor">The actor having this intention, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this intention, must not be <see langword="null"/></param>
            <param name="expression">The expression intended by this actor, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.CBA">
            <summary>
            Sentence type representing a can-bring-about temporal modality
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.CBA.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.CBA.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal can-bring-about modality
            </summary>
            <param name="actor">The actor who can bring this about, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this ability, must not be <see langword="null"/></param>
            <param name="expression">The expression whose truth this actor can attain, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.CBA.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new temporal can-bring-about modality
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="actor">The actor who can bring this about, must not be <see langword="null"/></param>
            <param name="time">The temporal duration of this ability, must not be <see langword="null"/></param>
            <param name="expression">The expression whose truth this actor can attain, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="actor"/>, <paramref name="time"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Quantifier">
            <summary>
            Sentence type representing an abstract logical quantification
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Quantifier.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Quantifier.#ctor(System.String,System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new quantification
            </summary>
            <param name="variable">The name of the variable of this quantification, must not be <see langword="null"/></param>
            <param name="set">The name of the object set range of this quantification, must not be <see langword="null"/></param>
            <param name="expression">The expression being quantified, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="variable"/> or <paramref name="set"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="variable"/>, <paramref name="set"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Quantifier.#ctor(System.String,System.String,System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new quantification
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="variable">The name of the variable of this quantification, must not be <see langword="null"/></param>
            <param name="set">The name of the object set range of this quantification, must not be <see langword="null"/></param>
            <param name="expression">The expression being quantified, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/>, <paramref name="variable"/>, or <paramref name="set"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="variable"/>, <paramref name="set"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Quantifier.Variable">
            <summary>
            Get or set the variable being quantified over
            </summary>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Quantifier.Set">
            <summary>
            Get or set the range of the variable being quantified over
            </summary>
            <exception cref="T:System.ArgumentException">When setting a value that is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Quantifier.Expression">
            <summary>
            Get or set the expression being quantified
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Exists">
            <summary>
            Sentence type representing an existential quantification
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Exists.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Exists.#ctor(System.String,System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new existential quantification
            </summary>
            <param name="variable">The name of the variable of this existential, must not be <see langword="null"/></param>
            <param name="set">The name of the object set range of this existential, must not be <see langword="null"/></param>
            <param name="expression">The expression being quantified, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="variable"/> or <paramref name="set"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="variable"/>, <paramref name="set"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Exists.#ctor(System.String,System.String,System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new existential quantification
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="variable">The name of the variable of this existential, must not be <see langword="null"/></param>
            <param name="set">The name of the object set range of this existential, must not be <see langword="null"/></param>
            <param name="expression">The expression being quantified, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/>, <paramref name="variable"/>, or <paramref name="set"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="variable"/>, <paramref name="set"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Forall">
            <summary>
            Sentence type representing a forall quantification
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Forall.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Forall.#ctor(System.String,System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new forall quantification
            </summary>
            <param name="variable">The name of the variable of this forall, must not be <see langword="null"/></param>
            <param name="set">The name of the object set range of this forall, must not be <see langword="null"/></param>
            <param name="expression">The expression being quantified, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="variable"/> or <paramref name="set"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="variable"/>, <paramref name="set"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Forall.#ctor(System.String,System.String,System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new forall quantification
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="variable">The name of the variable of this forall, must not be <see langword="null"/></param>
            <param name="set">The name of the object set range of this forall, must not be <see langword="null"/></param>
            <param name="expression">The expression being quantified, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/>, <paramref name="variable"/>, or <paramref name="set"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="variable"/>, <paramref name="set"/>, or <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.UnaryRelation">
            <summary>
            Sentence type representing an abstract unary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.UnaryRelation.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.UnaryRelation.#ctor(Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new unary relation
            </summary>
            <param name="expression">The expression of this relation, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.UnaryRelation.#ctor(System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new unary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="expression">The expression of this relation, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.UnaryRelation.Expression">
            <summary>
            Get or set the expression of this relation
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Not">
            <summary>
            Sentence type representing a NOT unary relation, saying an expression is never true
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Not.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Not.#ctor(Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical NOT
            </summary>
            <param name="expression">The expression to be negated, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Not.#ctor(System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical NOT
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="expression">The expression to be negated, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.WeakNot">
            <summary>
            Sentence type representing a WEAK-NOT unary relation, saying an expression is not always true
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.WeakNot.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.WeakNot.#ctor(Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical WEAK-NOT
            </summary>
            <param name="expression">The expression to be negated, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.WeakNot.#ctor(System.String,Impulse.v_1_336.Xml.Sentence)">
            <summary>
            Create a new logical WEAK-NOT
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="expression">The expression to be negated, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="expression"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.BinaryRelation">
            <summary>
            Sentence type representing an abstract binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelation.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelation.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelation.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.BinaryRelation.First">
            <summary>
            Get or set the first term of this relation (left-hand side)
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.BinaryRelation.Second">
            <summary>
            Get or set the second term of this relation (right-hand side)
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.ElementOf">
            <summary>
            Sentence type representing an element-of binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ElementOf.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ElementOf.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new element-of relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.ElementOf.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new element-of relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.RelationType">
            <summary>
            Types of temporal binary relations of intervals
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Equals">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)=start(t2) &amp;&amp; end(t1)=end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Before">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>end(t1)&lt;start(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.After">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&gt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Meets">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>end(t1)=start(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.IsMetBy">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)=end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Starts">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)=start(t2) &amp;&amp; end(t1)&lt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.IsStartedBy">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)=start(t2) &amp;&amp; end(t1)&gt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Finishes">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&gt;start(t2) &amp;&amp; end(t1)=end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.IsFinishedBy">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&lt;start(t2) &amp;&amp; end(t1)=end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.During">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&gt;start(t2) &amp;&amp; end(t1)&lt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Contains">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&lt;start(t2) &amp;&amp; end(t1)&gt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Overlaps">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&lt;start(t2)&lt;end(t1)&lt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.IsOverlappedBy">
            <summary>
            For intervals <c>t1</c> and <c>t2</c>, claims that <c>start(t1)&gt;start(t2)&gt;end(t1)&gt;end(t2)</c>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Subinterval">
            <summary>
            Flag representing any of <see cref="F:RelationType.Equals"/>, <see cref="F:RelationType.During"/>, <see cref="F:RelationType.Starts"/>, or <see cref="F:RelationType.Finishes"/>
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.RelationType.Precedes">
            <summary>
            Flag representing either of <see cref="F:RelationType.Before"/> or <see cref="F:RelationType.Meets"/>
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Xml.BinaryRelationTemporal">
            <summary>
            Sentence type representing an abstract temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelationTemporal.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelationTemporal.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new temporal binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelationTemporal.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new temporal binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.BinaryRelationTemporal.Type">
            <summary>
            Get or set the temporal relation type flags
            </summary>
            <remarks>Settings this property will not always work in subtypes</remarks>
        </member>
        <member name="T:Impulse.v_1_336.Xml.BinaryRelationTyped">
            <summary>
            Sentence type representing a temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelationTyped.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelationTyped.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.RelationType)">
            <summary>
            Create a new temporal binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <param name="type">The temporal relation type flags</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.BinaryRelationTyped.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.RelationType)">
            <summary>
            Create a new temporal binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <param name="type">The temporal relation type flags</param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.BinaryRelationTyped.Type">
            <summary>
            Get or set the temporal relation type flags
            </summary>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Equals">
            <summary>
            Sentence type representing an equals temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Equals.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Equals.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new equals binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Equals.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new equals binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Equals.Type">
            <summary>
            Get <see cref="F:RelationType.Equals"/>
            </summary>
            <remarks>This property cannot be set</remarks>
            <exception cref="T:System.InvalidOperationException">When setting this property to a value other than <see cref="F:RelationType.Equals"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Meets">
            <summary>
            Sentence type representing a meets temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Meets.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Meets.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new meets binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Meets.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new meets binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Meets.Type">
            <summary>
            Get <see cref="F:RelationType.Meets"/>
            </summary>
            <remarks>This property cannot be set</remarks>
            <exception cref="T:System.InvalidOperationException">When setting this property to a value other than <see cref="F:RelationType.Meets"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Precedes">
            <summary>
            Sentence type representing a precedes temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Precedes.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Precedes.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new precedes binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Precedes.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new precedes binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Precedes.Type">
            <summary>
            Get <see cref="F:RelationType.Precedes"/>
            </summary>
            <remarks>This property cannot be set</remarks>
            <exception cref="T:System.InvalidOperationException">When setting this property to a value other than <see cref="F:RelationType.Precedes"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Subinterval">
            <summary>
            Sentence type representing a subinterval temporal binary relation
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Subinterval.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Subinterval.#ctor(Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new subinterval binary relation
            </summary>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Subinterval.#ctor(System.String,Impulse.v_1_336.Xml.Term,Impulse.v_1_336.Xml.Term)">
            <summary>
            Create a new subinterval binary relation
            </summary>
            <param name="id">The ID of this sentence, must be a valid math name or <see langword="null"/></param>
            <param name="first">The first term of this relation (left-hand side), must not be <see langword="null"/></param>
            <param name="second">The second term of this relation (right-hand side), must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentException">If <paramref name="id"/> is not a valid math name</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="first"/> or <paramref name="second"/> is <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Subinterval.Type">
            <summary>
            Get <see cref="F:RelationType.Subinterval"/>
            </summary>
            <remarks>This property cannot be set</remarks>
            <exception cref="T:System.InvalidOperationException">When setting this property to a value other than <see cref="F:RelationType.Subinterval"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.Story">
            <summary>
            Class representing a story
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Story.Namespace">
            <summary>
            The namespace of the v.1.336 Impulse Story XML Schema
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Story.ObjectsSetName">
            <summary>
            The name of the set of all objects
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Story.ActionsSetName">
            <summary>
            The name of the set of all actions
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Story.ActorsSetName">
            <summary>
            The name of the set of all actors
            </summary>
        </member>
        <member name="F:Impulse.v_1_336.Xml.Story.IntervalSetName">
            <summary>
            The name of the set of all time intervals
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.#ctor">
            <summary>
            For <see cref="T:System.Xml.Serialization.XmlSerializer"/> use only.
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.#ctor(System.String,Impulse.v_1_336.Xml.ObjectSetRoot,Impulse.v_1_336.Xml.ActionSetRoot,Impulse.v_1_336.Xml.ActionPropertyDefinition[],Impulse.v_1_336.Xml.Action[],Impulse.v_1_336.Xml.Sentence[])">
            <summary>
            Create a new story
            </summary>
            <param name="name">The name of this story, must not be <see langword="null"/> or empty</param>
            <param name="objects">The set of all objects, must not be <see langword="null"/></param>
            <param name="actionTypes">The set of all action types, must not be <see langword="null"/></param>
            <param name="actionPropertyDefinitions">An array of all action properties, must not be <see langword="null"/></param>
            <param name="actions">An array of all actions, must not be <see langword="null"/></param>
            <param name="sentences">An array of all sentences, must not be <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="name"/>, <paramref name="objects"/>, <paramref name="actionTypes"/>
            <paramref name="actionPropertyDefinitions"/>, <paramref name="actions"/>, or
            <paramref name="sentences"/> is <see langword="null"/>
            </exception>
            <exception cref="T:System.ArgumentException">If <paramref name="name"/> is empty or whitespace</exception>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.ToString">
            <summary>
            Get the XML version of this object
            </summary>
            <returns>An XML representation of this object</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.LoadFromFile(System.String)">
            <summary>
            Deserialize a story from an XML file
            </summary>
            <param name="filename">The path to a file containing the story XML</param>
            <returns>A story object</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.Parse(System.String)">
            <summary>
            Deserialize a story from a string containing XML
            </summary>
            <param name="xml">A string containing XML</param>
            <returns>A story object</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.Parse(System.IO.Stream)">
            <summary>
            Deserialize a story from a stream containing XML
            </summary>
            <param name="stream">A stream containing XML</param>
            <returns>A story object</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.ComputeSets(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{System.String}}@,System.Collections.Generic.HashSet{System.String}@,System.Collections.Generic.Dictionary{System.String,Impulse.v_1_336.Xml.ActionSet}@,LN.Utilities.Collections.DirectedGraph{System.String,LN.Utilities.Collections.Edge{System.String}}@,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.IList{Impulse.v_1_336.Xml.ActionPropertyDefinition}}@)">
            <summary>
            Compute the object sets, action types, dependencies, and properties from this story
            </summary>
            <param name="actionDependencyGraph">The action type graph</param>
            <param name="objectSets">A dictionary of set names to object sets</param>
            <param name="allConstants">The set of all constants</param>
            <param name="actionSets">A dictionary of action type names to action sets</param>
            <param name="actionProperties">A dictionary of action type names to action properties</param>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.LoadSchemaFromManifest">
            <summary>
            Load the story XML schema from the manifest
            </summary>
            <returns>An XML schema for stories</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.LoadSchemaFromManifest(System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Load the story XML schema from the manifest
            </summary>
            <param name="handler">An event handler for schema validation events</param>
            <returns>An XML schema for stories</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.Story.Validate(System.Collections.Generic.IEnumerable{Impulse.v_1_336.IObjectSet},Impulse.v_1_336.IIntervalSet,Impulse.v_1_336.IConstantParser)">
            <summary>
            Validate a story
            </summary>
            <param name="includeSets">Extra object sets to include in validation</param>
            <param name="intervals">The set of intervals</param>
            <param name="intervalParser">An interval parser</param>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Story.Name">
            <summary>
            The name of this story
            </summary>
            <exception cref="T:System.ArgumentException">When attempting to set this value to an empty string or whitespace</exception>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Story.Objects">
            <summary>
            Get or set the set of all objects
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Story.ActionTypes">
            <summary>
            Get or set the set of all action types
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Story.ActionPropertyDefinitions">
            <summary>
            Get or set the array of action property definitions
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Story.Actions">
            <summary>
            Get or set the array of all actions
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="P:Impulse.v_1_336.Xml.Story.Sentences">
            <summary>
            Get or set the array of all sentences
            </summary>
            <exception cref="T:System.ArgumentNullException">When attempting to set this value to <see langword="null"/></exception>
        </member>
        <member name="T:Impulse.v_1_336.Xml.XmlSerializationExtensions">
            <summary>
            Extension methods for XML serialization
            </summary>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.SerializeToXml(Impulse.v_1_336.Xml.RelationType,System.Boolean)">
            <summary>
            Serialize a relation type to XML
            </summary>
            <param name="type">The relation to serialize</param>
            <returns>An XML representation of the relation</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.SerializeToXml(Impulse.v_1_336.Xml.ISupportsSerialization,System.Boolean)">
            <summary>
            Serialize an object to XML
            </summary>
            <param name="obj">The object to serialize</param>
            <returns>A string XML representation of the object</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.DeserializeXml``1(System.String)">
            <summary>
            Deserialize an object from XML
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <param name="xml">The string XML</param>
            <returns>A new object from the XML</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.DeserializeXml``1(System.IO.Stream)">
            <summary>
            Deserialize an object from XML
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <param name="stream">A stream containing the XML object</param>
            <returns>A new object from the XML</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.DeserializeXml(System.Type,System.String)">
            <summary>
            Deserialize an object from XML
            </summary>
            <param name="type">The type of object to deserialize</param>
            <param name="xml">The string XML</param>
            <returns>A new object from the XML</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.DeserializeXml(System.Type,System.IO.Stream)">
            <summary>
            Deserialize an object from XML
            </summary>
            <param name="type">The type of object to deserialize</param>
            <param name="stream">A stream containing the XML object</param>
            <returns>A new object from the XML</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.DeserializeXml(System.Type,System.IO.TextReader)">
            <summary>
            Deserialize an object from XML
            </summary>
            <param name="type">The type of object to deserialize</param>
            <param name="reader">A text reader containing the XML object</param>
            <returns>A new object from the XML</returns>
        </member>
        <member name="M:Impulse.v_1_336.Xml.XmlSerializationExtensions.GetXmlSerializer(System.Type)">
            <summary>
            Get the XML serializer for a specific type
            </summary>
            <param name="type">The type to get a serializer for</param>
            <returns>An XML serializer for the type</returns>
            <remarks>This is primarily a MONO workaround</remarks>
        </member>
    </members>
</doc>
